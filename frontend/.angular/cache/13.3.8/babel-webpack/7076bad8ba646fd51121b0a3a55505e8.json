{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, isDevMode, NgZone, Optional, VERSION as VERSION$1, PLATFORM_ID, NgModule, Inject } from '@angular/core';\nimport firebase from 'firebase/compat/app';\nimport { VERSION } from '@angular/fire'; // DEBUG quick debugger function for inline logging that typescript doesn't complain about\n//       wrote it for debugging the ɵlazySDKProxy, commenting out for now; should consider exposing a\n//       verbose mode for AngularFire in a future release that uses something like this in multiple places\n//       usage: () => log('something') || returnValue\n// const log = (...args: any[]): false => { console.log(...args); return false }\n// The problem here are things like ngOnDestroy are missing, then triggering the service\n// rather than dig too far; I'm capturing these as I go.\n\nconst noopFunctions = ['ngOnDestroy']; // INVESTIGATE should we make the Proxy revokable and do some cleanup?\n//             right now it's fairly simple but I'm sure this will grow in complexity\n\nconst ɵlazySDKProxy = (klass, observable, zone, options = {}) => {\n  return new Proxy(klass, {\n    get: (_, name) => zone.runOutsideAngular(() => {\n      var _a;\n\n      if (klass[name]) {\n        if ((_a = options === null || options === void 0 ? void 0 : options.spy) === null || _a === void 0 ? void 0 : _a.get) {\n          options.spy.get(name, klass[name]);\n        }\n\n        return klass[name];\n      }\n\n      if (noopFunctions.indexOf(name) > -1) {\n        return () => {};\n      }\n\n      const promise = observable.toPromise().then(mod => {\n        const ret = mod && mod[name]; // TODO move to proper type guards\n\n        if (typeof ret === 'function') {\n          return ret.bind(mod);\n        } else if (ret && ret.then) {\n          return ret.then(res => zone.run(() => res));\n        } else {\n          return zone.run(() => ret);\n        }\n      }); // recurse the proxy\n\n      return new Proxy(() => {}, {\n        get: (_, name) => promise[name],\n        // TODO handle callbacks as transparently as I can\n        apply: (self, _, args) => promise.then(it => {\n          var _a;\n\n          const res = it && it(...args);\n\n          if ((_a = options === null || options === void 0 ? void 0 : options.spy) === null || _a === void 0 ? void 0 : _a.apply) {\n            options.spy.apply(name, args, res);\n          }\n\n          return res;\n        })\n      });\n    })\n  });\n};\n\nconst ɵapplyMixins = (derivedCtor, constructors) => {\n  constructors.forEach(baseCtor => {\n    Object.getOwnPropertyNames(baseCtor.prototype || baseCtor).forEach(name => {\n      Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype || baseCtor, name));\n    });\n  });\n};\n\nclass FirebaseApp {\n  constructor(app) {\n    return app;\n  }\n\n}\n\nconst FIREBASE_OPTIONS = /*#__PURE__*/new InjectionToken('angularfire2.app.options');\nconst FIREBASE_APP_NAME = /*#__PURE__*/new InjectionToken('angularfire2.app.name');\n\nfunction ɵfirebaseAppFactory(options, zone, nameOrConfig) {\n  const name = typeof nameOrConfig === 'string' && nameOrConfig || '[DEFAULT]';\n  const config = typeof nameOrConfig === 'object' && nameOrConfig || {};\n  config.name = config.name || name; // Added any due to some inconsistency between @firebase/app and firebase types\n\n  const existingApp = firebase.apps.filter(app => app && app.name === config.name)[0]; // We support FirebaseConfig, initializeApp's public type only accepts string; need to cast as any\n  // Could be solved with https://github.com/firebase/firebase-js-sdk/pull/1206\n\n  const app = existingApp || zone.runOutsideAngular(() => firebase.initializeApp(options, config));\n\n  try {\n    if (JSON.stringify(options) !== JSON.stringify(app.options)) {\n      const hmr = !!module.hot;\n      log$1('error', `${app.name} Firebase App already initialized with different options${hmr ? ', you may need to reload as Firebase is not HMR aware.' : '.'}`);\n    }\n  } catch (e) {}\n\n  return new FirebaseApp(app);\n}\n\nconst log$1 = (level, ...args) => {\n  if (isDevMode() && typeof console !== 'undefined') {\n    console[level](...args);\n  }\n};\n\nconst FIREBASE_APP_PROVIDER = {\n  provide: FirebaseApp,\n  useFactory: ɵfirebaseAppFactory,\n  deps: [FIREBASE_OPTIONS, NgZone, [/*#__PURE__*/new Optional(), FIREBASE_APP_NAME]]\n};\nlet AngularFireModule = /*#__PURE__*/(() => {\n  class AngularFireModule {\n    // tslint:disable-next-line:ban-types\n    constructor(platformId) {\n      firebase.registerVersion('angularfire', VERSION.full, 'core');\n      firebase.registerVersion('angularfire', VERSION.full, 'app-compat');\n      firebase.registerVersion('angular', VERSION$1.full, platformId.toString());\n    }\n\n    static initializeApp(options, nameOrConfig) {\n      return {\n        ngModule: AngularFireModule,\n        providers: [{\n          provide: FIREBASE_OPTIONS,\n          useValue: options\n        }, {\n          provide: FIREBASE_APP_NAME,\n          useValue: nameOrConfig\n        }]\n      };\n    }\n\n  }\n\n  AngularFireModule.ɵfac = function AngularFireModule_Factory(t) {\n    return new (t || AngularFireModule)(i0.ɵɵinject(PLATFORM_ID));\n  };\n\n  AngularFireModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: AngularFireModule\n  });\n  AngularFireModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [FIREBASE_APP_PROVIDER]\n  });\n  return AngularFireModule;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction ɵcacheInstance(cacheKey, moduleName, appName, fn, deps) {\n  const [, instance, cachedDeps] = globalThis.ɵAngularfireInstanceCache.find(it => it[0] === cacheKey) || [];\n\n  if (instance) {\n    if (!matchDep(deps, cachedDeps)) {\n      log('error', `${moduleName} was already initialized on the ${appName} Firebase App with different settings.${IS_HMR ? ' You may need to reload as Firebase is not HMR aware.' : ''}`);\n      log('warn', {\n        is: deps,\n        was: cachedDeps\n      });\n    }\n\n    return instance;\n  } else {\n    const newInstance = fn();\n    globalThis.ɵAngularfireInstanceCache.push([cacheKey, newInstance, deps]);\n    return newInstance;\n  }\n}\n\nfunction matchDep(a, b) {\n  try {\n    return a.toString() === b.toString();\n  } catch (_) {\n    return a === b;\n  }\n}\n\nconst IS_HMR = !!module.hot;\n\nconst log = (level, ...args) => {\n  if (isDevMode() && typeof console !== 'undefined') {\n    console[level](...args);\n  }\n};\n\nglobalThis.ɵAngularfireInstanceCache || (globalThis.ɵAngularfireInstanceCache = []);\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AngularFireModule, FIREBASE_APP_NAME, FIREBASE_OPTIONS, FirebaseApp, ɵapplyMixins, ɵcacheInstance, ɵfirebaseAppFactory, ɵlazySDKProxy }; //# sourceMappingURL=angular-fire-compat.js.map","map":null,"metadata":{},"sourceType":"module"}