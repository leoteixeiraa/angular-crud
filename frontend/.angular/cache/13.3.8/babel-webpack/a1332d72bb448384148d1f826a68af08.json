{"ast":null,"code":"import _asyncToGenerator from \"/Users/leonardo/Desktop/GIT/angular-crud/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport firebase from '@firebase/app-compat';\nimport * as exp from '@firebase/auth/internal';\nimport { Component } from '@firebase/component';\nimport { isBrowserExtension, isReactNative, isNode, getUA, isIE, isIndexedDBAvailable, FirebaseError } from '@firebase/util';\nvar name = \"@firebase/auth-compat\";\nvar version = \"0.2.17\";\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nconst CORDOVA_ONDEVICEREADY_TIMEOUT_MS = 1000;\n\nfunction _getCurrentScheme() {\n  var _a;\n\n  return ((_a = self === null || self === void 0 ? void 0 : self.location) === null || _a === void 0 ? void 0 : _a.protocol) || null;\n}\n/**\r\n * @return {boolean} Whether the current environment is http or https.\r\n */\n\n\nfunction _isHttpOrHttps() {\n  return _getCurrentScheme() === 'http:' || _getCurrentScheme() === 'https:';\n}\n/**\r\n * @param {?string=} ua The user agent.\r\n * @return {boolean} Whether the app is rendered in a mobile iOS or Android\r\n *     Cordova environment.\r\n */\n\n\nfunction _isAndroidOrIosCordovaScheme(ua = getUA()) {\n  return !!((_getCurrentScheme() === 'file:' || _getCurrentScheme() === 'ionic:' || _getCurrentScheme() === 'capacitor:') && ua.toLowerCase().match(/iphone|ipad|ipod|android/));\n}\n/**\r\n * @return {boolean} Whether the environment is a native environment, where\r\n *     CORS checks do not apply.\r\n */\n\n\nfunction _isNativeEnvironment() {\n  return isReactNative() || isNode();\n}\n/**\r\n * Checks whether the user agent is IE11.\r\n * @return {boolean} True if it is IE11.\r\n */\n\n\nfunction _isIe11() {\n  return isIE() && (document === null || document === void 0 ? void 0 : document.documentMode) === 11;\n}\n/**\r\n * Checks whether the user agent is Edge.\r\n * @param {string} userAgent The browser user agent string.\r\n * @return {boolean} True if it is Edge.\r\n */\n\n\nfunction _isEdge(ua = getUA()) {\n  return /Edge\\/\\d+/.test(ua);\n}\n/**\r\n * @param {?string=} opt_userAgent The navigator user agent.\r\n * @return {boolean} Whether local storage is not synchronized between an iframe\r\n *     and a popup of the same domain.\r\n */\n\n\nfunction _isLocalStorageNotSynchronized(ua = getUA()) {\n  return _isIe11() || _isEdge(ua);\n}\n/** @return {boolean} Whether web storage is supported. */\n\n\nfunction _isWebStorageSupported() {\n  try {\n    const storage = self.localStorage;\n\n    const key = exp._generateEventId();\n\n    if (storage) {\n      // setItem will throw an exception if we cannot access WebStorage (e.g.,\n      // Safari in private mode).\n      storage['setItem'](key, '1');\n      storage['removeItem'](key); // For browsers where iframe web storage does not synchronize with a popup\n      // of the same domain, indexedDB is used for persistent storage. These\n      // browsers include IE11 and Edge.\n      // Make sure it is supported (IE11 and Edge private mode does not support\n      // that).\n\n      if (_isLocalStorageNotSynchronized()) {\n        // In such browsers, if indexedDB is not supported, an iframe cannot be\n        // notified of the popup sign in result.\n        return isIndexedDBAvailable();\n      }\n\n      return true;\n    }\n  } catch (e) {\n    // localStorage is not available from a worker. Test availability of\n    // indexedDB.\n    return _isWorker() && isIndexedDBAvailable();\n  }\n\n  return false;\n}\n/**\r\n * @param {?Object=} global The optional global scope.\r\n * @return {boolean} Whether current environment is a worker.\r\n */\n\n\nfunction _isWorker() {\n  // WorkerGlobalScope only defined in worker environment.\n  return typeof global !== 'undefined' && 'WorkerGlobalScope' in global && 'importScripts' in global;\n}\n\nfunction _isPopupRedirectSupported() {\n  return (_isHttpOrHttps() || isBrowserExtension() || _isAndroidOrIosCordovaScheme()) && // React Native with remote debugging reports its location.protocol as\n  // http.\n  !_isNativeEnvironment() && // Local storage has to be supported for browser popup and redirect\n  // operations to work.\n  _isWebStorageSupported() && // DOM, popups and redirects are not supported within a worker.\n  !_isWorker();\n}\n/** Quick check that indicates the platform *may* be Cordova */\n\n\nfunction _isLikelyCordova() {\n  return _isAndroidOrIosCordovaScheme() && typeof document !== 'undefined';\n}\n\nfunction _isCordova() {\n  return _isCordova2.apply(this, arguments);\n}\n\nfunction _isCordova2() {\n  _isCordova2 = _asyncToGenerator(function* () {\n    if (!_isLikelyCordova()) {\n      return false;\n    }\n\n    return new Promise(resolve => {\n      const timeoutId = setTimeout(() => {\n        // We've waited long enough; the telltale Cordova event didn't happen\n        resolve(false);\n      }, CORDOVA_ONDEVICEREADY_TIMEOUT_MS);\n      document.addEventListener('deviceready', () => {\n        clearTimeout(timeoutId);\n        resolve(true);\n      });\n    });\n  });\n  return _isCordova2.apply(this, arguments);\n}\n\nfunction _getSelfWindow() {\n  return typeof window !== 'undefined' ? window : null;\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nconst Persistence = {\n  LOCAL: 'local',\n  NONE: 'none',\n  SESSION: 'session'\n};\nconst _assert$3 = exp._assert;\nconst PERSISTENCE_KEY = 'persistence';\n/**\r\n * Validates that an argument is a valid persistence value. If an invalid type\r\n * is specified, an error is thrown synchronously.\r\n */\n\nfunction _validatePersistenceArgument(auth, persistence) {\n  _assert$3(Object.values(Persistence).includes(persistence), auth, \"invalid-persistence-type\"\n  /* INVALID_PERSISTENCE */\n  ); // Validate if the specified type is supported in the current environment.\n\n\n  if (isReactNative()) {\n    // This is only supported in a browser.\n    _assert$3(persistence !== Persistence.SESSION, auth, \"unsupported-persistence-type\"\n    /* UNSUPPORTED_PERSISTENCE */\n    );\n\n    return;\n  }\n\n  if (isNode()) {\n    // Only none is supported in Node.js.\n    _assert$3(persistence === Persistence.NONE, auth, \"unsupported-persistence-type\"\n    /* UNSUPPORTED_PERSISTENCE */\n    );\n\n    return;\n  }\n\n  if (_isWorker()) {\n    // In a worker environment, either LOCAL or NONE are supported.\n    // If indexedDB not supported and LOCAL provided, throw an error\n    _assert$3(persistence === Persistence.NONE || persistence === Persistence.LOCAL && isIndexedDBAvailable(), auth, \"unsupported-persistence-type\"\n    /* UNSUPPORTED_PERSISTENCE */\n    );\n\n    return;\n  } // This is restricted by what the browser supports.\n\n\n  _assert$3(persistence === Persistence.NONE || _isWebStorageSupported(), auth, \"unsupported-persistence-type\"\n  /* UNSUPPORTED_PERSISTENCE */\n  );\n}\n\nfunction _savePersistenceForRedirect(_x) {\n  return _savePersistenceForRedirect2.apply(this, arguments);\n}\n\nfunction _savePersistenceForRedirect2() {\n  _savePersistenceForRedirect2 = _asyncToGenerator(function* (auth) {\n    yield auth._initializationPromise;\n    const session = getSessionStorageIfAvailable();\n\n    const key = exp._persistenceKeyName(PERSISTENCE_KEY, auth.config.apiKey, auth.name);\n\n    if (session) {\n      session.setItem(key, auth._getPersistence());\n    }\n  });\n  return _savePersistenceForRedirect2.apply(this, arguments);\n}\n\nfunction _getPersistencesFromRedirect(apiKey, appName) {\n  const session = getSessionStorageIfAvailable();\n\n  if (!session) {\n    return [];\n  }\n\n  const key = exp._persistenceKeyName(PERSISTENCE_KEY, apiKey, appName);\n\n  const persistence = session.getItem(key);\n\n  switch (persistence) {\n    case Persistence.NONE:\n      return [exp.inMemoryPersistence];\n\n    case Persistence.LOCAL:\n      return [exp.indexedDBLocalPersistence, exp.browserSessionPersistence];\n\n    case Persistence.SESSION:\n      return [exp.browserSessionPersistence];\n\n    default:\n      return [];\n  }\n}\n/** Returns session storage, or null if the property access errors */\n\n\nfunction getSessionStorageIfAvailable() {\n  var _a;\n\n  try {\n    return ((_a = _getSelfWindow()) === null || _a === void 0 ? void 0 : _a.sessionStorage) || null;\n  } catch (e) {\n    return null;\n  }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nconst _assert$2 = exp._assert;\n/** Platform-agnostic popup-redirect resolver */\n\nclass CompatPopupRedirectResolver {\n  constructor() {\n    // Create both resolvers for dynamic resolution later\n    this.browserResolver = exp._getInstance(exp.browserPopupRedirectResolver);\n    this.cordovaResolver = exp._getInstance(exp.cordovaPopupRedirectResolver); // The actual resolver in use: either browserResolver or cordovaResolver.\n\n    this.underlyingResolver = null;\n    this._redirectPersistence = exp.browserSessionPersistence;\n    this._completeRedirectFn = exp._getRedirectResult;\n    this._overrideRedirectResult = exp._overrideRedirectResult;\n  }\n\n  _initialize(auth) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this.selectUnderlyingResolver();\n      return _this.assertedUnderlyingResolver._initialize(auth);\n    })();\n  }\n\n  _openPopup(auth, provider, authType, eventId) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this2.selectUnderlyingResolver();\n      return _this2.assertedUnderlyingResolver._openPopup(auth, provider, authType, eventId);\n    })();\n  }\n\n  _openRedirect(auth, provider, authType, eventId) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this3.selectUnderlyingResolver();\n      return _this3.assertedUnderlyingResolver._openRedirect(auth, provider, authType, eventId);\n    })();\n  }\n\n  _isIframeWebStorageSupported(auth, cb) {\n    this.assertedUnderlyingResolver._isIframeWebStorageSupported(auth, cb);\n  }\n\n  _originValidation(auth) {\n    return this.assertedUnderlyingResolver._originValidation(auth);\n  }\n\n  get _shouldInitProactively() {\n    return _isLikelyCordova() || this.browserResolver._shouldInitProactively;\n  }\n\n  get assertedUnderlyingResolver() {\n    _assert$2(this.underlyingResolver, \"internal-error\"\n    /* INTERNAL_ERROR */\n    );\n\n    return this.underlyingResolver;\n  }\n\n  selectUnderlyingResolver() {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this4.underlyingResolver) {\n        return;\n      } // We haven't yet determined whether or not we're in Cordova; go ahead\n      // and determine that state now.\n\n\n      const isCordova = yield _isCordova();\n      _this4.underlyingResolver = isCordova ? _this4.cordovaResolver : _this4.browserResolver;\n    })();\n  }\n\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nfunction unwrap(object) {\n  return object.unwrap();\n}\n\nfunction wrapped(object) {\n  return object.wrapped();\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nfunction credentialFromResponse(userCredential) {\n  return credentialFromObject(userCredential);\n}\n\nfunction attachExtraErrorFields(auth, e) {\n  var _a, _b; // The response contains all fields from the server which may or may not\n  // actually match the underlying type\n\n\n  const response = (_a = e.customData) === null || _a === void 0 ? void 0 : _a._tokenResponse;\n\n  if (((_b = e) === null || _b === void 0 ? void 0 : _b.code) === 'auth/multi-factor-auth-required') {\n    const mfaErr = e;\n    mfaErr.resolver = new MultiFactorResolver(auth, exp.getMultiFactorResolver(auth, e));\n  } else if (response) {\n    const credential = credentialFromObject(e);\n    const credErr = e;\n\n    if (credential) {\n      credErr.credential = credential;\n      credErr.tenantId = response.tenantId || undefined;\n      credErr.email = response.email || undefined;\n      credErr.phoneNumber = response.phoneNumber || undefined;\n    }\n  }\n}\n\nfunction credentialFromObject(object) {\n  const {\n    _tokenResponse\n  } = object instanceof FirebaseError ? object.customData : object;\n\n  if (!_tokenResponse) {\n    return null;\n  } // Handle phone Auth credential responses, as they have a different format\n  // from other backend responses (i.e. no providerId). This is also only the\n  // case for user credentials (does not work for errors).\n\n\n  if (!(object instanceof FirebaseError)) {\n    if ('temporaryProof' in _tokenResponse && 'phoneNumber' in _tokenResponse) {\n      return exp.PhoneAuthProvider.credentialFromResult(object);\n    }\n  }\n\n  const providerId = _tokenResponse.providerId; // Email and password is not supported as there is no situation where the\n  // server would return the password to the client.\n\n  if (!providerId || providerId === exp.ProviderId.PASSWORD) {\n    return null;\n  }\n\n  let provider;\n\n  switch (providerId) {\n    case exp.ProviderId.GOOGLE:\n      provider = exp.GoogleAuthProvider;\n      break;\n\n    case exp.ProviderId.FACEBOOK:\n      provider = exp.FacebookAuthProvider;\n      break;\n\n    case exp.ProviderId.GITHUB:\n      provider = exp.GithubAuthProvider;\n      break;\n\n    case exp.ProviderId.TWITTER:\n      provider = exp.TwitterAuthProvider;\n      break;\n\n    default:\n      const {\n        oauthIdToken,\n        oauthAccessToken,\n        oauthTokenSecret,\n        pendingToken,\n        nonce\n      } = _tokenResponse;\n\n      if (!oauthAccessToken && !oauthTokenSecret && !oauthIdToken && !pendingToken) {\n        return null;\n      } // TODO(avolkovi): uncomment this and get it working with SAML & OIDC\n\n\n      if (pendingToken) {\n        if (providerId.startsWith('saml.')) {\n          return exp.SAMLAuthCredential._create(providerId, pendingToken);\n        } else {\n          // OIDC and non-default providers excluding Twitter.\n          return exp.OAuthCredential._fromParams({\n            providerId,\n            signInMethod: providerId,\n            pendingToken,\n            idToken: oauthIdToken,\n            accessToken: oauthAccessToken\n          });\n        }\n      }\n\n      return new exp.OAuthProvider(providerId).credential({\n        idToken: oauthIdToken,\n        accessToken: oauthAccessToken,\n        rawNonce: nonce\n      });\n  }\n\n  return object instanceof FirebaseError ? provider.credentialFromError(object) : provider.credentialFromResult(object);\n}\n\nfunction convertCredential(auth, credentialPromise) {\n  return credentialPromise.catch(e => {\n    if (e instanceof FirebaseError) {\n      attachExtraErrorFields(auth, e);\n    }\n\n    throw e;\n  }).then(credential => {\n    const operationType = credential.operationType;\n    const user = credential.user;\n    return {\n      operationType,\n      credential: credentialFromResponse(credential),\n      additionalUserInfo: exp.getAdditionalUserInfo(credential),\n      user: User.getOrCreate(user)\n    };\n  });\n}\n\nfunction convertConfirmationResult(_x2, _x3) {\n  return _convertConfirmationResult.apply(this, arguments);\n}\n\nfunction _convertConfirmationResult() {\n  _convertConfirmationResult = _asyncToGenerator(function* (auth, confirmationResultPromise) {\n    const confirmationResultExp = yield confirmationResultPromise;\n    return {\n      verificationId: confirmationResultExp.verificationId,\n      confirm: verificationCode => convertCredential(auth, confirmationResultExp.confirm(verificationCode))\n    };\n  });\n  return _convertConfirmationResult.apply(this, arguments);\n}\n\nclass MultiFactorResolver {\n  constructor(auth, resolver) {\n    this.resolver = resolver;\n    this.auth = wrapped(auth);\n  }\n\n  get session() {\n    return this.resolver.session;\n  }\n\n  get hints() {\n    return this.resolver.hints;\n  }\n\n  resolveSignIn(assertion) {\n    return convertCredential(unwrap(this.auth), this.resolver.resolveSignIn(assertion));\n  }\n\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nclass User {\n  constructor(_delegate) {\n    this._delegate = _delegate;\n    this.multiFactor = exp.multiFactor(_delegate);\n  }\n\n  static getOrCreate(user) {\n    if (!User.USER_MAP.has(user)) {\n      User.USER_MAP.set(user, new User(user));\n    }\n\n    return User.USER_MAP.get(user);\n  }\n\n  delete() {\n    return this._delegate.delete();\n  }\n\n  reload() {\n    return this._delegate.reload();\n  }\n\n  toJSON() {\n    return this._delegate.toJSON();\n  }\n\n  getIdTokenResult(forceRefresh) {\n    return this._delegate.getIdTokenResult(forceRefresh);\n  }\n\n  getIdToken(forceRefresh) {\n    return this._delegate.getIdToken(forceRefresh);\n  }\n\n  linkAndRetrieveDataWithCredential(credential) {\n    return this.linkWithCredential(credential);\n  }\n\n  linkWithCredential(credential) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      return convertCredential(_this5.auth, exp.linkWithCredential(_this5._delegate, credential));\n    })();\n  }\n\n  linkWithPhoneNumber(phoneNumber, applicationVerifier) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      return convertConfirmationResult(_this6.auth, exp.linkWithPhoneNumber(_this6._delegate, phoneNumber, applicationVerifier));\n    })();\n  }\n\n  linkWithPopup(provider) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      return convertCredential(_this7.auth, exp.linkWithPopup(_this7._delegate, provider, CompatPopupRedirectResolver));\n    })();\n  }\n\n  linkWithRedirect(provider) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _savePersistenceForRedirect(exp._castAuth(_this8.auth));\n      return exp.linkWithRedirect(_this8._delegate, provider, CompatPopupRedirectResolver);\n    })();\n  }\n\n  reauthenticateAndRetrieveDataWithCredential(credential) {\n    return this.reauthenticateWithCredential(credential);\n  }\n\n  reauthenticateWithCredential(credential) {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      return convertCredential(_this9.auth, exp.reauthenticateWithCredential(_this9._delegate, credential));\n    })();\n  }\n\n  reauthenticateWithPhoneNumber(phoneNumber, applicationVerifier) {\n    return convertConfirmationResult(this.auth, exp.reauthenticateWithPhoneNumber(this._delegate, phoneNumber, applicationVerifier));\n  }\n\n  reauthenticateWithPopup(provider) {\n    return convertCredential(this.auth, exp.reauthenticateWithPopup(this._delegate, provider, CompatPopupRedirectResolver));\n  }\n\n  reauthenticateWithRedirect(provider) {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _savePersistenceForRedirect(exp._castAuth(_this10.auth));\n      return exp.reauthenticateWithRedirect(_this10._delegate, provider, CompatPopupRedirectResolver);\n    })();\n  }\n\n  sendEmailVerification(actionCodeSettings) {\n    return exp.sendEmailVerification(this._delegate, actionCodeSettings);\n  }\n\n  unlink(providerId) {\n    var _this11 = this;\n\n    return _asyncToGenerator(function* () {\n      yield exp.unlink(_this11._delegate, providerId);\n      return _this11;\n    })();\n  }\n\n  updateEmail(newEmail) {\n    return exp.updateEmail(this._delegate, newEmail);\n  }\n\n  updatePassword(newPassword) {\n    return exp.updatePassword(this._delegate, newPassword);\n  }\n\n  updatePhoneNumber(phoneCredential) {\n    return exp.updatePhoneNumber(this._delegate, phoneCredential);\n  }\n\n  updateProfile(profile) {\n    return exp.updateProfile(this._delegate, profile);\n  }\n\n  verifyBeforeUpdateEmail(newEmail, actionCodeSettings) {\n    return exp.verifyBeforeUpdateEmail(this._delegate, newEmail, actionCodeSettings);\n  }\n\n  get emailVerified() {\n    return this._delegate.emailVerified;\n  }\n\n  get isAnonymous() {\n    return this._delegate.isAnonymous;\n  }\n\n  get metadata() {\n    return this._delegate.metadata;\n  }\n\n  get phoneNumber() {\n    return this._delegate.phoneNumber;\n  }\n\n  get providerData() {\n    return this._delegate.providerData;\n  }\n\n  get refreshToken() {\n    return this._delegate.refreshToken;\n  }\n\n  get tenantId() {\n    return this._delegate.tenantId;\n  }\n\n  get displayName() {\n    return this._delegate.displayName;\n  }\n\n  get email() {\n    return this._delegate.email;\n  }\n\n  get photoURL() {\n    return this._delegate.photoURL;\n  }\n\n  get providerId() {\n    return this._delegate.providerId;\n  }\n\n  get uid() {\n    return this._delegate.uid;\n  }\n\n  get auth() {\n    return this._delegate.auth;\n  }\n\n} // Maintain a map so that there's always a 1:1 mapping between new User and\n// legacy compat users\n\n\nUser.USER_MAP = new WeakMap();\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nconst _assert$1 = exp._assert;\nlet Auth = /*#__PURE__*/(() => {\n  class Auth {\n    constructor(app, provider) {\n      this.app = app;\n\n      if (provider.isInitialized()) {\n        this._delegate = provider.getImmediate();\n        this.linkUnderlyingAuth();\n        return;\n      }\n\n      const {\n        apiKey\n      } = app.options; // TODO: platform needs to be determined using heuristics\n\n      _assert$1(apiKey, \"invalid-api-key\"\n      /* INVALID_API_KEY */\n      , {\n        appName: app.name\n      }); // TODO: platform needs to be determined using heuristics\n\n\n      _assert$1(apiKey, \"invalid-api-key\"\n      /* INVALID_API_KEY */\n      , {\n        appName: app.name\n      }); // Only use a popup/redirect resolver in browser environments\n\n\n      const resolver = typeof window !== 'undefined' ? CompatPopupRedirectResolver : undefined;\n      this._delegate = provider.initialize({\n        options: {\n          persistence: buildPersistenceHierarchy(apiKey, app.name),\n          popupRedirectResolver: resolver\n        }\n      });\n\n      this._delegate._updateErrorMap(exp.debugErrorMap);\n\n      this.linkUnderlyingAuth();\n    }\n\n    get emulatorConfig() {\n      return this._delegate.emulatorConfig;\n    }\n\n    get currentUser() {\n      if (!this._delegate.currentUser) {\n        return null;\n      }\n\n      return User.getOrCreate(this._delegate.currentUser);\n    }\n\n    get languageCode() {\n      return this._delegate.languageCode;\n    }\n\n    set languageCode(languageCode) {\n      this._delegate.languageCode = languageCode;\n    }\n\n    get settings() {\n      return this._delegate.settings;\n    }\n\n    get tenantId() {\n      return this._delegate.tenantId;\n    }\n\n    set tenantId(tid) {\n      this._delegate.tenantId = tid;\n    }\n\n    useDeviceLanguage() {\n      this._delegate.useDeviceLanguage();\n    }\n\n    signOut() {\n      return this._delegate.signOut();\n    }\n\n    useEmulator(url, options) {\n      exp.connectAuthEmulator(this._delegate, url, options);\n    }\n\n    applyActionCode(code) {\n      return exp.applyActionCode(this._delegate, code);\n    }\n\n    checkActionCode(code) {\n      return exp.checkActionCode(this._delegate, code);\n    }\n\n    confirmPasswordReset(code, newPassword) {\n      return exp.confirmPasswordReset(this._delegate, code, newPassword);\n    }\n\n    createUserWithEmailAndPassword(email, password) {\n      var _this12 = this;\n\n      return _asyncToGenerator(function* () {\n        return convertCredential(_this12._delegate, exp.createUserWithEmailAndPassword(_this12._delegate, email, password));\n      })();\n    }\n\n    fetchProvidersForEmail(email) {\n      return this.fetchSignInMethodsForEmail(email);\n    }\n\n    fetchSignInMethodsForEmail(email) {\n      return exp.fetchSignInMethodsForEmail(this._delegate, email);\n    }\n\n    isSignInWithEmailLink(emailLink) {\n      return exp.isSignInWithEmailLink(this._delegate, emailLink);\n    }\n\n    getRedirectResult() {\n      var _this13 = this;\n\n      return _asyncToGenerator(function* () {\n        _assert$1(_isPopupRedirectSupported(), _this13._delegate, \"operation-not-supported-in-this-environment\"\n        /* OPERATION_NOT_SUPPORTED */\n        );\n\n        const credential = yield exp.getRedirectResult(_this13._delegate, CompatPopupRedirectResolver);\n\n        if (!credential) {\n          return {\n            credential: null,\n            user: null\n          };\n        }\n\n        return convertCredential(_this13._delegate, Promise.resolve(credential));\n      })();\n    } // This function should only be called by frameworks (e.g. FirebaseUI-web) to log their usage.\n    // It is not intended for direct use by developer apps. NO jsdoc here to intentionally leave it\n    // out of autogenerated documentation pages to reduce accidental misuse.\n\n\n    addFrameworkForLogging(framework) {\n      exp.addFrameworkForLogging(this._delegate, framework);\n    }\n\n    onAuthStateChanged(nextOrObserver, errorFn, completed) {\n      const {\n        next,\n        error,\n        complete\n      } = wrapObservers(nextOrObserver, errorFn, completed);\n      return this._delegate.onAuthStateChanged(next, error, complete);\n    }\n\n    onIdTokenChanged(nextOrObserver, errorFn, completed) {\n      const {\n        next,\n        error,\n        complete\n      } = wrapObservers(nextOrObserver, errorFn, completed);\n      return this._delegate.onIdTokenChanged(next, error, complete);\n    }\n\n    sendSignInLinkToEmail(email, actionCodeSettings) {\n      return exp.sendSignInLinkToEmail(this._delegate, email, actionCodeSettings);\n    }\n\n    sendPasswordResetEmail(email, actionCodeSettings) {\n      return exp.sendPasswordResetEmail(this._delegate, email, actionCodeSettings || undefined);\n    }\n\n    setPersistence(persistence) {\n      var _this14 = this;\n\n      return _asyncToGenerator(function* () {\n        _validatePersistenceArgument(_this14._delegate, persistence);\n\n        let converted;\n\n        switch (persistence) {\n          case Persistence.SESSION:\n            converted = exp.browserSessionPersistence;\n            break;\n\n          case Persistence.LOCAL:\n            // Not using isIndexedDBAvailable() since it only checks if indexedDB is defined.\n            const isIndexedDBFullySupported = yield exp._getInstance(exp.indexedDBLocalPersistence)._isAvailable();\n            converted = isIndexedDBFullySupported ? exp.indexedDBLocalPersistence : exp.browserLocalPersistence;\n            break;\n\n          case Persistence.NONE:\n            converted = exp.inMemoryPersistence;\n            break;\n\n          default:\n            return exp._fail(\"argument-error\"\n            /* ARGUMENT_ERROR */\n            , {\n              appName: _this14._delegate.name\n            });\n        }\n\n        return _this14._delegate.setPersistence(converted);\n      })();\n    }\n\n    signInAndRetrieveDataWithCredential(credential) {\n      return this.signInWithCredential(credential);\n    }\n\n    signInAnonymously() {\n      return convertCredential(this._delegate, exp.signInAnonymously(this._delegate));\n    }\n\n    signInWithCredential(credential) {\n      return convertCredential(this._delegate, exp.signInWithCredential(this._delegate, credential));\n    }\n\n    signInWithCustomToken(token) {\n      return convertCredential(this._delegate, exp.signInWithCustomToken(this._delegate, token));\n    }\n\n    signInWithEmailAndPassword(email, password) {\n      return convertCredential(this._delegate, exp.signInWithEmailAndPassword(this._delegate, email, password));\n    }\n\n    signInWithEmailLink(email, emailLink) {\n      return convertCredential(this._delegate, exp.signInWithEmailLink(this._delegate, email, emailLink));\n    }\n\n    signInWithPhoneNumber(phoneNumber, applicationVerifier) {\n      return convertConfirmationResult(this._delegate, exp.signInWithPhoneNumber(this._delegate, phoneNumber, applicationVerifier));\n    }\n\n    signInWithPopup(provider) {\n      var _this15 = this;\n\n      return _asyncToGenerator(function* () {\n        _assert$1(_isPopupRedirectSupported(), _this15._delegate, \"operation-not-supported-in-this-environment\"\n        /* OPERATION_NOT_SUPPORTED */\n        );\n\n        return convertCredential(_this15._delegate, exp.signInWithPopup(_this15._delegate, provider, CompatPopupRedirectResolver));\n      })();\n    }\n\n    signInWithRedirect(provider) {\n      var _this16 = this;\n\n      return _asyncToGenerator(function* () {\n        _assert$1(_isPopupRedirectSupported(), _this16._delegate, \"operation-not-supported-in-this-environment\"\n        /* OPERATION_NOT_SUPPORTED */\n        );\n\n        yield _savePersistenceForRedirect(_this16._delegate);\n        return exp.signInWithRedirect(_this16._delegate, provider, CompatPopupRedirectResolver);\n      })();\n    }\n\n    updateCurrentUser(user) {\n      // remove ts-ignore once overloads are defined for exp functions to accept compat objects\n      // @ts-ignore\n      return this._delegate.updateCurrentUser(user);\n    }\n\n    verifyPasswordResetCode(code) {\n      return exp.verifyPasswordResetCode(this._delegate, code);\n    }\n\n    unwrap() {\n      return this._delegate;\n    }\n\n    _delete() {\n      return this._delegate._delete();\n    }\n\n    linkUnderlyingAuth() {\n      this._delegate.wrapped = () => this;\n    }\n\n  }\n\n  Auth.Persistence = Persistence;\n  return Auth;\n})();\n\nfunction wrapObservers(nextOrObserver, error, complete) {\n  let next = nextOrObserver;\n\n  if (typeof nextOrObserver !== 'function') {\n    ({\n      next,\n      error,\n      complete\n    } = nextOrObserver);\n  } // We know 'next' is now a function\n\n\n  const oldNext = next;\n\n  const newNext = user => oldNext(user && User.getOrCreate(user));\n\n  return {\n    next: newNext,\n    error: error,\n    complete\n  };\n}\n\nfunction buildPersistenceHierarchy(apiKey, appName) {\n  // Note this is slightly different behavior: in this case, the stored\n  // persistence is checked *first* rather than last. This is because we want\n  // to prefer stored persistence type in the hierarchy. This is an empty\n  // array if window is not available or there is no pending redirect\n  const persistences = _getPersistencesFromRedirect(apiKey, appName); // If \"self\" is available, add indexedDB\n\n\n  if (typeof self !== 'undefined' && !persistences.includes(exp.indexedDBLocalPersistence)) {\n    persistences.push(exp.indexedDBLocalPersistence);\n  } // If \"window\" is available, add HTML Storage persistences\n\n\n  if (typeof window !== 'undefined') {\n    for (const persistence of [exp.browserLocalPersistence, exp.browserSessionPersistence]) {\n      if (!persistences.includes(persistence)) {\n        persistences.push(persistence);\n      }\n    }\n  } // Add in-memory as a final fallback\n\n\n  if (!persistences.includes(exp.inMemoryPersistence)) {\n    persistences.push(exp.inMemoryPersistence);\n  }\n\n  return persistences;\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nclass PhoneAuthProvider {\n  constructor() {\n    this.providerId = 'phone'; // TODO: remove ts-ignore when moving types from auth-types to auth-compat\n    // @ts-ignore\n\n    this._delegate = new exp.PhoneAuthProvider(unwrap(firebase.auth()));\n  }\n\n  static credential(verificationId, verificationCode) {\n    return exp.PhoneAuthProvider.credential(verificationId, verificationCode);\n  }\n\n  verifyPhoneNumber(phoneInfoOptions, applicationVerifier) {\n    return this._delegate.verifyPhoneNumber( // The implementation matches but the types are subtly incompatible\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    phoneInfoOptions, applicationVerifier);\n  }\n\n  unwrap() {\n    return this._delegate;\n  }\n\n}\n\nPhoneAuthProvider.PHONE_SIGN_IN_METHOD = exp.PhoneAuthProvider.PHONE_SIGN_IN_METHOD;\nPhoneAuthProvider.PROVIDER_ID = exp.PhoneAuthProvider.PROVIDER_ID;\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nconst _assert = exp._assert;\n\nclass RecaptchaVerifier {\n  constructor(container, parameters, app = firebase.app()) {\n    var _a; // API key is required for web client RPC calls.\n\n\n    _assert((_a = app.options) === null || _a === void 0 ? void 0 : _a.apiKey, \"invalid-api-key\"\n    /* INVALID_API_KEY */\n    , {\n      appName: app.name\n    });\n\n    this._delegate = new exp.RecaptchaVerifier(container, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    parameters, // TODO: remove ts-ignore when moving types from auth-types to auth-compat\n    // @ts-ignore\n    app.auth());\n    this.type = this._delegate.type;\n  }\n\n  clear() {\n    this._delegate.clear();\n  }\n\n  render() {\n    return this._delegate.render();\n  }\n\n  verify() {\n    return this._delegate.verify();\n  }\n\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nconst AUTH_TYPE = 'auth-compat'; // Create auth components to register with firebase.\n// Provides Auth public APIs.\n\nfunction registerAuthCompat(instance) {\n  instance.INTERNAL.registerComponent(new Component(AUTH_TYPE, container => {\n    // getImmediate for FirebaseApp will always succeed\n    const app = container.getProvider('app-compat').getImmediate();\n    const authProvider = container.getProvider('auth');\n    return new Auth(app, authProvider);\n  }, \"PUBLIC\"\n  /* PUBLIC */\n  ).setServiceProps({\n    ActionCodeInfo: {\n      Operation: {\n        EMAIL_SIGNIN: exp.ActionCodeOperation.EMAIL_SIGNIN,\n        PASSWORD_RESET: exp.ActionCodeOperation.PASSWORD_RESET,\n        RECOVER_EMAIL: exp.ActionCodeOperation.RECOVER_EMAIL,\n        REVERT_SECOND_FACTOR_ADDITION: exp.ActionCodeOperation.REVERT_SECOND_FACTOR_ADDITION,\n        VERIFY_AND_CHANGE_EMAIL: exp.ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL,\n        VERIFY_EMAIL: exp.ActionCodeOperation.VERIFY_EMAIL\n      }\n    },\n    EmailAuthProvider: exp.EmailAuthProvider,\n    FacebookAuthProvider: exp.FacebookAuthProvider,\n    GithubAuthProvider: exp.GithubAuthProvider,\n    GoogleAuthProvider: exp.GoogleAuthProvider,\n    OAuthProvider: exp.OAuthProvider,\n    SAMLAuthProvider: exp.SAMLAuthProvider,\n    PhoneAuthProvider: PhoneAuthProvider,\n    PhoneMultiFactorGenerator: exp.PhoneMultiFactorGenerator,\n    RecaptchaVerifier: RecaptchaVerifier,\n    TwitterAuthProvider: exp.TwitterAuthProvider,\n    Auth,\n    AuthCredential: exp.AuthCredential,\n    Error: FirebaseError\n  }).setInstantiationMode(\"LAZY\"\n  /* LAZY */\n  ).setMultipleInstances(false));\n  instance.registerVersion(name, version);\n}\n\nregisterAuthCompat(firebase); //# sourceMappingURL=index.esm2017.js.map","map":null,"metadata":{},"sourceType":"module"}