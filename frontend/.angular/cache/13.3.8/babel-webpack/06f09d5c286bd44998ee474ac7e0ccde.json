{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, Optional, NgModule } from '@angular/core';\nimport { Subject, of, Observable, from, merge } from 'rxjs';\nimport { observeOn, switchMap, map, shareReplay, first, switchMapTo, subscribeOn, filter } from 'rxjs/operators';\nimport * as i1 from '@angular/fire';\nimport { keepUnstableUntilFirst, VERSION } from '@angular/fire';\nimport { ɵcacheInstance, ɵfirebaseAppFactory, ɵlazySDKProxy, FIREBASE_OPTIONS, FIREBASE_APP_NAME, ɵapplyMixins } from '@angular/fire/compat';\nimport { isPlatformServer } from '@angular/common';\nimport * as i2 from '@angular/fire/app-check';\nimport firebase from 'firebase/compat/app'; // DO NOT MODIFY, this file is autogenerated by tools/build.ts\n// Export a null object with the same keys as firebase/compat/auth, so Proxy can work with proxy-polyfill in Internet Explorer\n\nconst proxyPolyfillCompat = {\n  name: null,\n  config: null,\n  emulatorConfig: null,\n  app: null,\n  applyActionCode: null,\n  checkActionCode: null,\n  confirmPasswordReset: null,\n  createUserWithEmailAndPassword: null,\n  currentUser: null,\n  fetchSignInMethodsForEmail: null,\n  isSignInWithEmailLink: null,\n  getRedirectResult: null,\n  languageCode: null,\n  settings: null,\n  onAuthStateChanged: null,\n  onIdTokenChanged: null,\n  sendSignInLinkToEmail: null,\n  sendPasswordResetEmail: null,\n  setPersistence: null,\n  signInAndRetrieveDataWithCredential: null,\n  signInAnonymously: null,\n  signInWithCredential: null,\n  signInWithCustomToken: null,\n  signInWithEmailAndPassword: null,\n  signInWithPhoneNumber: null,\n  signInWithEmailLink: null,\n  signInWithPopup: null,\n  signInWithRedirect: null,\n  signOut: null,\n  tenantId: null,\n  updateCurrentUser: null,\n  useDeviceLanguage: null,\n  useEmulator: null,\n  verifyPasswordResetCode: null\n};\nconst USE_EMULATOR = /*#__PURE__*/new InjectionToken('angularfire2.auth.use-emulator');\nconst SETTINGS = /*#__PURE__*/new InjectionToken('angularfire2.auth.settings');\nconst TENANT_ID = /*#__PURE__*/new InjectionToken('angularfire2.auth.tenant-id');\nconst LANGUAGE_CODE = /*#__PURE__*/new InjectionToken('angularfire2.auth.langugage-code');\nconst USE_DEVICE_LANGUAGE = /*#__PURE__*/new InjectionToken('angularfire2.auth.use-device-language');\nconst PERSISTENCE = /*#__PURE__*/new InjectionToken('angularfire.auth.persistence');\n\nconst ɵauthFactory = (app, zone, useEmulator, tenantId, languageCode, useDeviceLanguage, settings, persistence) => ɵcacheInstance(`${app.name}.auth`, 'AngularFireAuth', app.name, () => {\n  const auth = zone.runOutsideAngular(() => app.auth());\n\n  if (useEmulator) {\n    auth.useEmulator(...useEmulator);\n  }\n\n  if (tenantId) {\n    auth.tenantId = tenantId;\n  }\n\n  auth.languageCode = languageCode;\n\n  if (useDeviceLanguage) {\n    auth.useDeviceLanguage();\n  }\n\n  if (settings) {\n    for (const [k, v] of Object.entries(settings)) {\n      auth.settings[k] = v;\n    }\n  }\n\n  if (persistence) {\n    auth.setPersistence(persistence);\n  }\n\n  return auth;\n}, [useEmulator, tenantId, languageCode, useDeviceLanguage, settings, persistence]);\n\nlet AngularFireAuth = /*#__PURE__*/(() => {\n  class AngularFireAuth {\n    constructor(options, name, // tslint:disable-next-line:ban-types\n    platformId, zone, schedulers, useEmulator, // can't use the tuple here\n    settings, // can't use firebase.auth.AuthSettings here\n    tenantId, languageCode, useDeviceLanguage, persistence, _appCheckInstances) {\n      const logins = new Subject();\n      const auth = of(undefined).pipe(observeOn(schedulers.outsideAngular), switchMap(() => zone.runOutsideAngular(() => import('firebase/compat/auth'))), map(() => ɵfirebaseAppFactory(options, zone, name)), map(app => ɵauthFactory(app, zone, useEmulator, tenantId, languageCode, useDeviceLanguage, settings, persistence)), shareReplay({\n        bufferSize: 1,\n        refCount: false\n      }));\n\n      if (isPlatformServer(platformId)) {\n        this.authState = this.user = this.idToken = this.idTokenResult = this.credential = of(null);\n      } else {\n        // HACK, as we're exporting auth.Auth, rather than auth, developers importing firebase.auth\n        //       (e.g, `import { auth } from 'firebase/compat/app'`) are getting an undefined auth object unexpectedly\n        //       as we're completely lazy. Let's eagerly load the Auth SDK here.\n        //       There could potentially be race conditions still... but this greatly decreases the odds while\n        //       we reevaluate the API.\n        const _ = auth.pipe(first()).subscribe();\n\n        const redirectResult = auth.pipe(switchMap(auth => auth.getRedirectResult().then(it => it, () => null)), keepUnstableUntilFirst, shareReplay({\n          bufferSize: 1,\n          refCount: false\n        }));\n        const authStateChanged = auth.pipe(switchMap(auth => new Observable(sub => ({\n          unsubscribe: zone.runOutsideAngular(() => auth.onAuthStateChanged(next => sub.next(next), err => sub.error(err), () => sub.complete()))\n        }))));\n        const idTokenChanged = auth.pipe(switchMap(auth => new Observable(sub => ({\n          unsubscribe: zone.runOutsideAngular(() => auth.onIdTokenChanged(next => sub.next(next), err => sub.error(err), () => sub.complete()))\n        }))));\n        this.authState = redirectResult.pipe(switchMapTo(authStateChanged), subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));\n        this.user = redirectResult.pipe(switchMapTo(idTokenChanged), subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));\n        this.idToken = this.user.pipe(switchMap(user => user ? from(user.getIdToken()) : of(null)));\n        this.idTokenResult = this.user.pipe(switchMap(user => user ? from(user.getIdTokenResult()) : of(null)));\n        this.credential = merge(redirectResult, logins, // pipe in null authState to make credential zipable, just a weird devexp if\n        // authState and user go null to still have a credential\n        this.authState.pipe(filter(it => !it))).pipe( // handle the { user: { } } when a user is already logged in, rather have null\n        // TODO handle the type corcersion better\n        map(credential => (credential === null || credential === void 0 ? void 0 : credential.user) ? credential : null), subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));\n      }\n\n      return ɵlazySDKProxy(this, auth, zone, {\n        spy: {\n          apply: (name, _, val) => {\n            // If they call a signIn or createUser function listen into the promise\n            // this will give us the user credential, push onto the logins Subject\n            // to be consumed in .credential\n            if (name.startsWith('signIn') || name.startsWith('createUser')) {\n              // TODO fix the types, the trouble is UserCredential has everything optional\n              val.then(user => logins.next(user));\n            }\n          }\n        }\n      });\n    }\n\n  }\n\n  AngularFireAuth.ɵfac = function AngularFireAuth_Factory(t) {\n    return new (t || AngularFireAuth)(i0.ɵɵinject(FIREBASE_OPTIONS), i0.ɵɵinject(FIREBASE_APP_NAME, 8), i0.ɵɵinject(PLATFORM_ID), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i1.ɵAngularFireSchedulers), i0.ɵɵinject(USE_EMULATOR, 8), i0.ɵɵinject(SETTINGS, 8), i0.ɵɵinject(TENANT_ID, 8), i0.ɵɵinject(LANGUAGE_CODE, 8), i0.ɵɵinject(USE_DEVICE_LANGUAGE, 8), i0.ɵɵinject(PERSISTENCE, 8), i0.ɵɵinject(i2.AppCheckInstances, 8));\n  };\n\n  AngularFireAuth.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AngularFireAuth,\n    factory: AngularFireAuth.ɵfac,\n    providedIn: 'any'\n  });\n  return AngularFireAuth;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*#__PURE__*/\nɵapplyMixins(AngularFireAuth, [proxyPolyfillCompat]);\nlet AngularFireAuthModule = /*#__PURE__*/(() => {\n  class AngularFireAuthModule {\n    constructor() {\n      firebase.registerVersion('angularfire', VERSION.full, 'auth-compat');\n    }\n\n  }\n\n  AngularFireAuthModule.ɵfac = function AngularFireAuthModule_Factory(t) {\n    return new (t || AngularFireAuthModule)();\n  };\n\n  AngularFireAuthModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: AngularFireAuthModule\n  });\n  AngularFireAuthModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [AngularFireAuth]\n  });\n  return AngularFireAuthModule;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { AngularFireAuth, AngularFireAuthModule, LANGUAGE_CODE, PERSISTENCE, SETTINGS, TENANT_ID, USE_DEVICE_LANGUAGE, USE_EMULATOR, ɵauthFactory }; //# sourceMappingURL=angular-fire-compat-auth.js.map","map":null,"metadata":{},"sourceType":"module"}