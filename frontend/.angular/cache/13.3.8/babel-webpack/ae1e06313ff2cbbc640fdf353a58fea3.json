{"ast":null,"code":"import _asyncToGenerator from \"/Users/leonardo/Desktop/GIT/angular-crud/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { ap as _isIOS7Or8, aq as debugAssert, ar as _isIOS, as as _isAndroid, at as _fail, au as _getRedirectUrl, av as _getProjectConfig, aw as _createError, ax as _assert, ay as _getInstance, b as browserLocalPersistence, az as _persistenceKeyName, aA as AuthEventManager, a as browserSessionPersistence, aB as _getRedirectResult, aC as _overrideRedirectResult, aD as _clearRedirectOutcomes, aE as _castAuth } from './index-58473f72.js';\nexport { A as ActionCodeOperation, ad as ActionCodeURL, H as AuthCredential, D as AuthErrorCodes, aG as AuthImpl, aJ as AuthPopup, I as EmailAuthCredential, M as EmailAuthProvider, N as FacebookAuthProvider, F as FactorId, aK as FetchProvider, T as GithubAuthProvider, Q as GoogleAuthProvider, J as OAuthCredential, U as OAuthProvider, O as OperationType, K as PhoneAuthCredential, P as PhoneAuthProvider, m as PhoneMultiFactorGenerator, o as ProviderId, R as RecaptchaVerifier, aL as SAMLAuthCredential, V as SAMLAuthProvider, S as SignInMethod, W as TwitterAuthProvider, aF as UserImpl, ax as _assert, aE as _castAuth, at as _fail, aI as _generateEventId, aH as _getClientVersion, ay as _getInstance, aB as _getRedirectResult, aC as _overrideRedirectResult, az as _persistenceKeyName, a2 as applyActionCode, t as beforeAuthStateChanged, b as browserLocalPersistence, k as browserPopupRedirectResolver, a as browserSessionPersistence, a3 as checkActionCode, a1 as confirmPasswordReset, G as connectAuthEmulator, a5 as createUserWithEmailAndPassword, B as debugErrorMap, z as deleteUser, aa as fetchSignInMethodsForEmail, al as getAdditionalUserInfo, n as getAuth, ai as getIdToken, aj as getIdTokenResult, an as getMultiFactorResolver, j as getRedirectResult, L as inMemoryPersistence, i as indexedDBLocalPersistence, E as initializeAuth, a8 as isSignInWithEmailLink, Z as linkWithCredential, l as linkWithPhoneNumber, d as linkWithPopup, g as linkWithRedirect, ao as multiFactor, v as onAuthStateChanged, q as onIdTokenChanged, ae as parseActionCodeURL, C as prodErrorMap, _ as reauthenticateWithCredential, r as reauthenticateWithPhoneNumber, e as reauthenticateWithPopup, h as reauthenticateWithRedirect, am as reload, ab as sendEmailVerification, a0 as sendPasswordResetEmail, a7 as sendSignInLinkToEmail, p as setPersistence, X as signInAnonymously, Y as signInWithCredential, $ as signInWithCustomToken, a6 as signInWithEmailAndPassword, a9 as signInWithEmailLink, s as signInWithPhoneNumber, c as signInWithPopup, f as signInWithRedirect, y as signOut, ak as unlink, x as updateCurrentUser, ag as updateEmail, ah as updatePassword, u as updatePhoneNumber, af as updateProfile, w as useDeviceLanguage, ac as verifyBeforeUpdateEmail, a4 as verifyPasswordResetCode } from './index-58473f72.js';\nimport { querystringDecode } from '@firebase/util';\nimport '@firebase/app';\nimport 'tslib';\nimport '@firebase/logger';\nimport '@firebase/component';\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nfunction _cordovaWindow() {\n  return window;\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * How long to wait after the app comes back into focus before concluding that\r\n * the user closed the sign in tab.\r\n */\n\n\nconst REDIRECT_TIMEOUT_MS = 2000;\n/**\r\n * Generates the URL for the OAuth handler.\r\n */\n\nfunction _generateHandlerUrl(_x, _x2, _x3) {\n  return _generateHandlerUrl2.apply(this, arguments);\n}\n/**\r\n * Validates that this app is valid for this project configuration\r\n */\n\n\nfunction _generateHandlerUrl2() {\n  _generateHandlerUrl2 = _asyncToGenerator(function* (auth, event, provider) {\n    var _a; // Get the cordova plugins\n\n\n    const {\n      BuildInfo\n    } = _cordovaWindow();\n\n    debugAssert(event.sessionId, 'AuthEvent did not contain a session ID');\n    const sessionDigest = yield computeSha256(event.sessionId);\n    const additionalParams = {};\n\n    if (_isIOS()) {\n      // iOS app identifier\n      additionalParams['ibi'] = BuildInfo.packageName;\n    } else if (_isAndroid()) {\n      // Android app identifier\n      additionalParams['apn'] = BuildInfo.packageName;\n    } else {\n      _fail(auth, \"operation-not-supported-in-this-environment\"\n      /* OPERATION_NOT_SUPPORTED */\n      );\n    } // Add the display name if available\n\n\n    if (BuildInfo.displayName) {\n      additionalParams['appDisplayName'] = BuildInfo.displayName;\n    } // Attached the hashed session ID\n\n\n    additionalParams['sessionId'] = sessionDigest;\n    return _getRedirectUrl(auth, provider, event.type, undefined, (_a = event.eventId) !== null && _a !== void 0 ? _a : undefined, additionalParams);\n  });\n  return _generateHandlerUrl2.apply(this, arguments);\n}\n\nfunction _validateOrigin(_x4) {\n  return _validateOrigin2.apply(this, arguments);\n}\n\nfunction _validateOrigin2() {\n  _validateOrigin2 = _asyncToGenerator(function* (auth) {\n    const {\n      BuildInfo\n    } = _cordovaWindow();\n\n    const request = {};\n\n    if (_isIOS()) {\n      request.iosBundleId = BuildInfo.packageName;\n    } else if (_isAndroid()) {\n      request.androidPackageName = BuildInfo.packageName;\n    } else {\n      _fail(auth, \"operation-not-supported-in-this-environment\"\n      /* OPERATION_NOT_SUPPORTED */\n      );\n    } // Will fail automatically if package name is not authorized\n\n\n    yield _getProjectConfig(auth, request);\n  });\n  return _validateOrigin2.apply(this, arguments);\n}\n\nfunction _performRedirect(handlerUrl) {\n  // Get the cordova plugins\n  const {\n    cordova\n  } = _cordovaWindow();\n\n  return new Promise(resolve => {\n    cordova.plugins.browsertab.isAvailable(browserTabIsAvailable => {\n      let iabRef = null;\n\n      if (browserTabIsAvailable) {\n        cordova.plugins.browsertab.openUrl(handlerUrl);\n      } else {\n        // TODO: Return the inappbrowser ref that's returned from the open call\n        iabRef = cordova.InAppBrowser.open(handlerUrl, _isIOS7Or8() ? '_blank' : '_system', 'location=yes');\n      }\n\n      resolve(iabRef);\n    });\n  });\n}\n/**\r\n * This function waits for app activity to be seen before resolving. It does\r\n * this by attaching listeners to various dom events. Once the app is determined\r\n * to be visible, this promise resolves. AFTER that resolution, the listeners\r\n * are detached and any browser tabs left open will be closed.\r\n */\n\n\nfunction _waitForAppResume(_x5, _x6, _x7) {\n  return _waitForAppResume2.apply(this, arguments);\n}\n/**\r\n * Checks the configuration of the Cordova environment. This has no side effect\r\n * if the configuration is correct; otherwise it throws an error with the\r\n * missing plugin.\r\n */\n\n\nfunction _waitForAppResume2() {\n  _waitForAppResume2 = _asyncToGenerator(function* (auth, eventListener, iabRef) {\n    // Get the cordova plugins\n    const {\n      cordova\n    } = _cordovaWindow();\n\n    let cleanup = () => {};\n\n    try {\n      yield new Promise((resolve, reject) => {\n        let onCloseTimer = null; // DEFINE ALL THE CALLBACKS =====\n\n        function authEventSeen() {\n          var _a; // Auth event was detected. Resolve this promise and close the extra\n          // window if it's still open.\n\n\n          resolve();\n          const closeBrowserTab = (_a = cordova.plugins.browsertab) === null || _a === void 0 ? void 0 : _a.close;\n\n          if (typeof closeBrowserTab === 'function') {\n            closeBrowserTab();\n          } // Close inappbrowser emebedded webview in iOS7 and 8 case if still\n          // open.\n\n\n          if (typeof (iabRef === null || iabRef === void 0 ? void 0 : iabRef.close) === 'function') {\n            iabRef.close();\n          }\n        }\n\n        function resumed() {\n          if (onCloseTimer) {\n            // This code already ran; do not rerun.\n            return;\n          }\n\n          onCloseTimer = window.setTimeout(() => {\n            // Wait two seeconds after resume then reject.\n            reject(_createError(auth, \"redirect-cancelled-by-user\"\n            /* REDIRECT_CANCELLED_BY_USER */\n            ));\n          }, REDIRECT_TIMEOUT_MS);\n        }\n\n        function visibilityChanged() {\n          if ((document === null || document === void 0 ? void 0 : document.visibilityState) === 'visible') {\n            resumed();\n          }\n        } // ATTACH ALL THE LISTENERS =====\n        // Listen for the auth event\n\n\n        eventListener.addPassiveListener(authEventSeen); // Listen for resume and visibility events\n\n        document.addEventListener('resume', resumed, false);\n\n        if (_isAndroid()) {\n          document.addEventListener('visibilitychange', visibilityChanged, false);\n        } // SETUP THE CLEANUP FUNCTION =====\n\n\n        cleanup = () => {\n          eventListener.removePassiveListener(authEventSeen);\n          document.removeEventListener('resume', resumed, false);\n          document.removeEventListener('visibilitychange', visibilityChanged, false);\n\n          if (onCloseTimer) {\n            window.clearTimeout(onCloseTimer);\n          }\n        };\n      });\n    } finally {\n      cleanup();\n    }\n  });\n  return _waitForAppResume2.apply(this, arguments);\n}\n\nfunction _checkCordovaConfiguration(auth) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n\n  const win = _cordovaWindow(); // Check all dependencies installed.\n  // https://github.com/nordnet/cordova-universal-links-plugin\n  // Note that cordova-universal-links-plugin has been abandoned.\n  // A fork with latest fixes is available at:\n  // https://www.npmjs.com/package/cordova-universal-links-plugin-fix\n\n\n  _assert(typeof ((_a = win === null || win === void 0 ? void 0 : win.universalLinks) === null || _a === void 0 ? void 0 : _a.subscribe) === 'function', auth, \"invalid-cordova-configuration\"\n  /* INVALID_CORDOVA_CONFIGURATION */\n  , {\n    missingPlugin: 'cordova-universal-links-plugin-fix'\n  }); // https://www.npmjs.com/package/cordova-plugin-buildinfo\n\n\n  _assert(typeof ((_b = win === null || win === void 0 ? void 0 : win.BuildInfo) === null || _b === void 0 ? void 0 : _b.packageName) !== 'undefined', auth, \"invalid-cordova-configuration\"\n  /* INVALID_CORDOVA_CONFIGURATION */\n  , {\n    missingPlugin: 'cordova-plugin-buildInfo'\n  }); // https://github.com/google/cordova-plugin-browsertab\n\n\n  _assert(typeof ((_e = (_d = (_c = win === null || win === void 0 ? void 0 : win.cordova) === null || _c === void 0 ? void 0 : _c.plugins) === null || _d === void 0 ? void 0 : _d.browsertab) === null || _e === void 0 ? void 0 : _e.openUrl) === 'function', auth, \"invalid-cordova-configuration\"\n  /* INVALID_CORDOVA_CONFIGURATION */\n  , {\n    missingPlugin: 'cordova-plugin-browsertab'\n  });\n\n  _assert(typeof ((_h = (_g = (_f = win === null || win === void 0 ? void 0 : win.cordova) === null || _f === void 0 ? void 0 : _f.plugins) === null || _g === void 0 ? void 0 : _g.browsertab) === null || _h === void 0 ? void 0 : _h.isAvailable) === 'function', auth, \"invalid-cordova-configuration\"\n  /* INVALID_CORDOVA_CONFIGURATION */\n  , {\n    missingPlugin: 'cordova-plugin-browsertab'\n  }); // https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-inappbrowser/\n\n\n  _assert(typeof ((_k = (_j = win === null || win === void 0 ? void 0 : win.cordova) === null || _j === void 0 ? void 0 : _j.InAppBrowser) === null || _k === void 0 ? void 0 : _k.open) === 'function', auth, \"invalid-cordova-configuration\"\n  /* INVALID_CORDOVA_CONFIGURATION */\n  , {\n    missingPlugin: 'cordova-plugin-inappbrowser'\n  });\n}\n/**\r\n * Computes the SHA-256 of a session ID. The SubtleCrypto interface is only\r\n * available in \"secure\" contexts, which covers Cordova (which is served on a file\r\n * protocol).\r\n */\n\n\nfunction computeSha256(_x8) {\n  return _computeSha.apply(this, arguments);\n}\n\nfunction _computeSha() {\n  _computeSha = _asyncToGenerator(function* (sessionId) {\n    const bytes = stringToArrayBuffer(sessionId); // TODO: For IE11 crypto has a different name and this operation comes back\n    //       as an object, not a promise. This is the old proposed standard that\n    //       is used by IE11:\n    // https://www.w3.org/TR/2013/WD-WebCryptoAPI-20130108/#cryptooperation-interface\n\n    const buf = yield crypto.subtle.digest('SHA-256', bytes);\n    const arr = Array.from(new Uint8Array(buf));\n    return arr.map(num => num.toString(16).padStart(2, '0')).join('');\n  });\n  return _computeSha.apply(this, arguments);\n}\n\nfunction stringToArrayBuffer(str) {\n  // This function is only meant to deal with an ASCII charset and makes\n  // certain simplifying assumptions.\n  debugAssert(/[0-9a-zA-Z]+/.test(str), 'Can only convert alpha-numeric strings');\n\n  if (typeof TextEncoder !== 'undefined') {\n    return new TextEncoder().encode(str);\n  }\n\n  const buff = new ArrayBuffer(str.length);\n  const view = new Uint8Array(buff);\n\n  for (let i = 0; i < str.length; i++) {\n    view[i] = str.charCodeAt(i);\n  }\n\n  return view;\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nconst SESSION_ID_LENGTH = 20;\n/** Custom AuthEventManager that adds passive listeners to events */\n\nclass CordovaAuthEventManager extends AuthEventManager {\n  constructor() {\n    super(...arguments);\n    this.passiveListeners = new Set();\n    this.initPromise = new Promise(resolve => {\n      this.resolveInialized = resolve;\n    });\n  }\n\n  addPassiveListener(cb) {\n    this.passiveListeners.add(cb);\n  }\n\n  removePassiveListener(cb) {\n    this.passiveListeners.delete(cb);\n  } // In a Cordova environment, this manager can live through multiple redirect\n  // operations\n\n\n  resetRedirect() {\n    this.queuedRedirectEvent = null;\n    this.hasHandledPotentialRedirect = false;\n  }\n  /** Override the onEvent method */\n\n\n  onEvent(event) {\n    this.resolveInialized();\n    this.passiveListeners.forEach(cb => cb(event));\n    return super.onEvent(event);\n  }\n\n  initialized() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this.initPromise;\n    })();\n  }\n\n}\n/**\r\n * Generates a (partial) {@link AuthEvent}.\r\n */\n\n\nfunction _generateNewEvent(auth, type, eventId = null) {\n  return {\n    type,\n    eventId,\n    urlResponse: null,\n    sessionId: generateSessionId(),\n    postBody: null,\n    tenantId: auth.tenantId,\n    error: _createError(auth, \"no-auth-event\"\n    /* NO_AUTH_EVENT */\n    )\n  };\n}\n\nfunction _savePartialEvent(auth, event) {\n  return storage()._set(persistenceKey(auth), event);\n}\n\nfunction _getAndRemoveEvent(_x9) {\n  return _getAndRemoveEvent2.apply(this, arguments);\n}\n\nfunction _getAndRemoveEvent2() {\n  _getAndRemoveEvent2 = _asyncToGenerator(function* (auth) {\n    const event = yield storage()._get(persistenceKey(auth));\n\n    if (event) {\n      yield storage()._remove(persistenceKey(auth));\n    }\n\n    return event;\n  });\n  return _getAndRemoveEvent2.apply(this, arguments);\n}\n\nfunction _eventFromPartialAndUrl(partialEvent, url) {\n  var _a, _b; // Parse the deep link within the dynamic link URL.\n\n\n  const callbackUrl = _getDeepLinkFromCallback(url); // Confirm it is actually a callback URL.\n  // Currently the universal link will be of this format:\n  // https://<AUTH_DOMAIN>/__/auth/callback<OAUTH_RESPONSE>\n  // This is a fake URL but is not intended to take the user anywhere\n  // and just redirect to the app.\n\n\n  if (callbackUrl.includes('/__/auth/callback')) {\n    // Check if there is an error in the URL.\n    // This mechanism is also used to pass errors back to the app:\n    // https://<AUTH_DOMAIN>/__/auth/callback?firebaseError=<STRINGIFIED_ERROR>\n    const params = searchParamsOrEmpty(callbackUrl); // Get the error object corresponding to the stringified error if found.\n\n    const errorObject = params['firebaseError'] ? parseJsonOrNull(decodeURIComponent(params['firebaseError'])) : null;\n    const code = (_b = (_a = errorObject === null || errorObject === void 0 ? void 0 : errorObject['code']) === null || _a === void 0 ? void 0 : _a.split('auth/')) === null || _b === void 0 ? void 0 : _b[1];\n    const error = code ? _createError(code) : null;\n\n    if (error) {\n      return {\n        type: partialEvent.type,\n        eventId: partialEvent.eventId,\n        tenantId: partialEvent.tenantId,\n        error,\n        urlResponse: null,\n        sessionId: null,\n        postBody: null\n      };\n    } else {\n      return {\n        type: partialEvent.type,\n        eventId: partialEvent.eventId,\n        tenantId: partialEvent.tenantId,\n        sessionId: partialEvent.sessionId,\n        urlResponse: callbackUrl,\n        postBody: null\n      };\n    }\n  }\n\n  return null;\n}\n\nfunction generateSessionId() {\n  const chars = [];\n  const allowedChars = '1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\n  for (let i = 0; i < SESSION_ID_LENGTH; i++) {\n    const idx = Math.floor(Math.random() * allowedChars.length);\n    chars.push(allowedChars.charAt(idx));\n  }\n\n  return chars.join('');\n}\n\nfunction storage() {\n  return _getInstance(browserLocalPersistence);\n}\n\nfunction persistenceKey(auth) {\n  return _persistenceKeyName(\"authEvent\"\n  /* AUTH_EVENT */\n  , auth.config.apiKey, auth.name);\n}\n\nfunction parseJsonOrNull(json) {\n  try {\n    return JSON.parse(json);\n  } catch (e) {\n    return null;\n  }\n} // Exported for testing\n\n\nfunction _getDeepLinkFromCallback(url) {\n  const params = searchParamsOrEmpty(url);\n  const link = params['link'] ? decodeURIComponent(params['link']) : undefined; // Double link case (automatic redirect)\n\n  const doubleDeepLink = searchParamsOrEmpty(link)['link']; // iOS custom scheme links.\n\n  const iOSDeepLink = params['deep_link_id'] ? decodeURIComponent(params['deep_link_id']) : undefined;\n  const iOSDoubleDeepLink = searchParamsOrEmpty(iOSDeepLink)['link'];\n  return iOSDoubleDeepLink || iOSDeepLink || doubleDeepLink || link || url;\n}\n/**\r\n * Optimistically tries to get search params from a string, or else returns an\r\n * empty search params object.\r\n */\n\n\nfunction searchParamsOrEmpty(url) {\n  if (!(url === null || url === void 0 ? void 0 : url.includes('?'))) {\n    return {};\n  }\n\n  const [_, ...rest] = url.split('?');\n  return querystringDecode(rest.join('?'));\n}\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * How long to wait for the initial auth event before concluding no\r\n * redirect pending\r\n */\n\n\nconst INITIAL_EVENT_TIMEOUT_MS = 500;\n\nclass CordovaPopupRedirectResolver {\n  constructor() {\n    this._redirectPersistence = browserSessionPersistence;\n    this._shouldInitProactively = true; // This is lightweight for Cordova\n\n    this.eventManagers = new Map();\n    this.originValidationPromises = {};\n    this._completeRedirectFn = _getRedirectResult;\n    this._overrideRedirectResult = _overrideRedirectResult;\n  }\n\n  _initialize(auth) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const key = auth._key();\n\n      let manager = _this2.eventManagers.get(key);\n\n      if (!manager) {\n        manager = new CordovaAuthEventManager(auth);\n\n        _this2.eventManagers.set(key, manager);\n\n        _this2.attachCallbackListeners(auth, manager);\n      }\n\n      return manager;\n    })();\n  }\n\n  _openPopup(auth) {\n    _fail(auth, \"operation-not-supported-in-this-environment\"\n    /* OPERATION_NOT_SUPPORTED */\n    );\n  }\n\n  _openRedirect(auth, provider, authType, eventId) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      _checkCordovaConfiguration(auth);\n\n      const manager = yield _this3._initialize(auth);\n      yield manager.initialized(); // Reset the persisted redirect states. This does not matter on Web where\n      // the redirect always blows away application state entirely. On Cordova,\n      // the app maintains control flow through the redirect.\n\n      manager.resetRedirect();\n\n      _clearRedirectOutcomes();\n\n      yield _this3._originValidation(auth);\n\n      const event = _generateNewEvent(auth, authType, eventId);\n\n      yield _savePartialEvent(auth, event);\n      const url = yield _generateHandlerUrl(auth, event, provider);\n      const iabRef = yield _performRedirect(url);\n      return _waitForAppResume(auth, manager, iabRef);\n    })();\n  }\n\n  _isIframeWebStorageSupported(_auth, _cb) {\n    throw new Error('Method not implemented.');\n  }\n\n  _originValidation(auth) {\n    const key = auth._key();\n\n    if (!this.originValidationPromises[key]) {\n      this.originValidationPromises[key] = _validateOrigin(auth);\n    }\n\n    return this.originValidationPromises[key];\n  }\n\n  attachCallbackListeners(auth, manager) {\n    // Get the global plugins\n    const {\n      universalLinks,\n      handleOpenURL,\n      BuildInfo\n    } = _cordovaWindow();\n\n    const noEventTimeout = setTimeout( /*#__PURE__*/_asyncToGenerator(function* () {\n      // We didn't see that initial event. Clear any pending object and\n      // dispatch no event\n      yield _getAndRemoveEvent(auth);\n      manager.onEvent(generateNoEvent());\n    }), INITIAL_EVENT_TIMEOUT_MS);\n\n    const universalLinksCb = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(function* (eventData) {\n        // We have an event so we can clear the no event timeout\n        clearTimeout(noEventTimeout);\n        const partialEvent = yield _getAndRemoveEvent(auth);\n        let finalEvent = null;\n\n        if (partialEvent && (eventData === null || eventData === void 0 ? void 0 : eventData['url'])) {\n          finalEvent = _eventFromPartialAndUrl(partialEvent, eventData['url']);\n        } // If finalEvent is never filled, trigger with no event\n\n\n        manager.onEvent(finalEvent || generateNoEvent());\n      });\n\n      return function universalLinksCb(_x10) {\n        return _ref2.apply(this, arguments);\n      };\n    }(); // Universal links subscriber doesn't exist for iOS, so we need to check\n\n\n    if (typeof universalLinks !== 'undefined' && typeof universalLinks.subscribe === 'function') {\n      universalLinks.subscribe(null, universalLinksCb);\n    } // iOS 7 or 8 custom URL schemes.\n    // This is also the current default behavior for iOS 9+.\n    // For this to work, cordova-plugin-customurlscheme needs to be installed.\n    // https://github.com/EddyVerbruggen/Custom-URL-scheme\n    // Do not overwrite the existing developer's URL handler.\n\n\n    const existingHandleOpenURL = handleOpenURL;\n    const packagePrefix = `${BuildInfo.packageName.toLowerCase()}://`;\n\n    _cordovaWindow().handleOpenURL = /*#__PURE__*/function () {\n      var _ref3 = _asyncToGenerator(function* (url) {\n        if (url.toLowerCase().startsWith(packagePrefix)) {\n          // We want this intentionally to float\n          // eslint-disable-next-line @typescript-eslint/no-floating-promises\n          universalLinksCb({\n            url\n          });\n        } // Call the developer's handler if it is present.\n\n\n        if (typeof existingHandleOpenURL === 'function') {\n          try {\n            existingHandleOpenURL(url);\n          } catch (e) {\n            // This is a developer error. Don't stop the flow of the SDK.\n            console.error(e);\n          }\n        }\n      });\n\n      return function (_x11) {\n        return _ref3.apply(this, arguments);\n      };\n    }();\n  }\n\n}\n/**\r\n * An implementation of {@link PopupRedirectResolver} suitable for Cordova\r\n * based applications.\r\n *\r\n * @public\r\n */\n\n\nconst cordovaPopupRedirectResolver = CordovaPopupRedirectResolver;\n\nfunction generateNoEvent() {\n  return {\n    type: \"unknown\"\n    /* UNKNOWN */\n    ,\n    eventId: null,\n    sessionId: null,\n    urlResponse: null,\n    postBody: null,\n    tenantId: null,\n    error: _createError(\"no-auth-event\"\n    /* NO_AUTH_EVENT */\n    )\n  };\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n// This function should only be called by frameworks (e.g. FirebaseUI-web) to log their usage.\n// It is not intended for direct use by developer apps. NO jsdoc here to intentionally leave it out\n// of autogenerated documentation pages to reduce accidental misuse.\n\n\nfunction addFrameworkForLogging(auth, framework) {\n  _castAuth(auth)._logFramework(framework);\n}\n\nexport { addFrameworkForLogging, cordovaPopupRedirectResolver }; //# sourceMappingURL=internal.js.map","map":null,"metadata":{},"sourceType":"module"}