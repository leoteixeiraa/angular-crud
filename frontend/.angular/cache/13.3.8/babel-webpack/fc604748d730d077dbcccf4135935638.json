{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, Optional, NgModule } from '@angular/core';\nimport { asyncScheduler, Observable, from, of } from 'rxjs';\nimport * as i1 from '@angular/fire';\nimport { keepUnstableUntilFirst, VERSION } from '@angular/fire';\nimport { startWith, pairwise, map, scan, distinctUntilChanged, filter } from 'rxjs/operators';\nimport { ɵfirebaseAppFactory, ɵcacheInstance, FIREBASE_OPTIONS, FIREBASE_APP_NAME } from '@angular/fire/compat';\nimport { isPlatformServer } from '@angular/common';\nimport 'firebase/compat/auth';\nimport 'firebase/compat/firestore';\nimport * as i2 from '@angular/fire/compat/auth';\nimport { ɵauthFactory, USE_EMULATOR as USE_EMULATOR$1, SETTINGS as SETTINGS$1, TENANT_ID, LANGUAGE_CODE, USE_DEVICE_LANGUAGE, PERSISTENCE } from '@angular/fire/compat/auth';\nimport * as i3 from '@angular/fire/app-check';\nimport firebase from 'firebase/compat/app';\n\nfunction _fromRef(ref, scheduler = asyncScheduler) {\n  return new Observable(subscriber => {\n    let unsubscribe;\n\n    if (scheduler != null) {\n      scheduler.schedule(() => {\n        unsubscribe = ref.onSnapshot({\n          includeMetadataChanges: true\n        }, subscriber);\n      });\n    } else {\n      unsubscribe = ref.onSnapshot({\n        includeMetadataChanges: true\n      }, subscriber);\n    }\n\n    return () => {\n      if (unsubscribe != null) {\n        unsubscribe();\n      }\n    };\n  });\n}\n\nfunction fromRef(ref, scheduler) {\n  return _fromRef(ref, scheduler);\n}\n\nfunction fromDocRef(ref, scheduler) {\n  return fromRef(ref, scheduler).pipe(startWith(undefined), pairwise(), map(([priorPayload, payload]) => {\n    if (!payload.exists) {\n      return {\n        payload,\n        type: 'removed'\n      };\n    }\n\n    if (!(priorPayload === null || priorPayload === void 0 ? void 0 : priorPayload.exists)) {\n      return {\n        payload,\n        type: 'added'\n      };\n    }\n\n    return {\n      payload,\n      type: 'modified'\n    };\n  }));\n}\n\nfunction fromCollectionRef(ref, scheduler) {\n  return fromRef(ref, scheduler).pipe(map(payload => ({\n    payload,\n    type: 'query'\n  })));\n}\n/**\n * Return a stream of document changes on a query. These results are not in sort order but in\n * order of occurence.\n */\n\n\nfunction docChanges(query, scheduler) {\n  return fromCollectionRef(query, scheduler).pipe(startWith(undefined), pairwise(), map(([priorAction, action]) => {\n    const docChanges = action.payload.docChanges();\n    const actions = docChanges.map(change => ({\n      type: change.type,\n      payload: change\n    })); // the metadata has changed from the prior emission\n\n    if (priorAction && JSON.stringify(priorAction.payload.metadata) !== JSON.stringify(action.payload.metadata)) {\n      // go through all the docs in payload and figure out which ones changed\n      action.payload.docs.forEach((currentDoc, currentIndex) => {\n        const docChange = docChanges.find(d => d.doc.ref.isEqual(currentDoc.ref));\n        const priorDoc = priorAction === null || priorAction === void 0 ? void 0 : priorAction.payload.docs.find(d => d.ref.isEqual(currentDoc.ref));\n\n        if (docChange && JSON.stringify(docChange.doc.metadata) === JSON.stringify(currentDoc.metadata) || !docChange && priorDoc && JSON.stringify(priorDoc.metadata) === JSON.stringify(currentDoc.metadata)) {// document doesn't appear to have changed, don't log another action\n        } else {\n          // since the actions are processed in order just push onto the array\n          actions.push({\n            type: 'modified',\n            payload: {\n              oldIndex: currentIndex,\n              newIndex: currentIndex,\n              type: 'modified',\n              doc: currentDoc\n            }\n          });\n        }\n      });\n    }\n\n    return actions;\n  }));\n}\n/**\n * Return a stream of document changes on a query. These results are in sort order.\n */\n\n\nfunction sortedChanges(query, events, scheduler) {\n  return docChanges(query, scheduler).pipe(scan((current, changes) => combineChanges(current, changes.map(it => it.payload), events), []), distinctUntilChanged(), // cut down on unneed change cycles\n  map(changes => changes.map(c => ({\n    type: c.type,\n    payload: c\n  }))));\n}\n/**\n * Combines the total result set from the current set of changes from an incoming set\n * of changes.\n */\n\n\nfunction combineChanges(current, changes, events) {\n  changes.forEach(change => {\n    // skip unwanted change types\n    if (events.indexOf(change.type) > -1) {\n      current = combineChange(current, change);\n    }\n  });\n  return current;\n}\n/**\n * Splice arguments on top of a sliced array, to break top-level ===\n * this is useful for change-detection\n */\n\n\nfunction sliceAndSplice(original, start, deleteCount, ...args) {\n  const returnArray = original.slice();\n  returnArray.splice(start, deleteCount, ...args);\n  return returnArray;\n}\n/**\n * Creates a new sorted array from a new change.\n * Build our own because we allow filtering of action types ('added', 'removed', 'modified') before scanning\n * and so we have greater control over change detection (by breaking ===)\n */\n\n\nfunction combineChange(combined, change) {\n  switch (change.type) {\n    case 'added':\n      if (combined[change.newIndex] && combined[change.newIndex].doc.ref.isEqual(change.doc.ref)) {// Not sure why the duplicates are getting fired\n      } else {\n        return sliceAndSplice(combined, change.newIndex, 0, change);\n      }\n\n      break;\n\n    case 'modified':\n      if (combined[change.oldIndex] == null || combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n        // When an item changes position we first remove it\n        // and then add it's new position\n        if (change.oldIndex !== change.newIndex) {\n          const copiedArray = combined.slice();\n          copiedArray.splice(change.oldIndex, 1);\n          copiedArray.splice(change.newIndex, 0, change);\n          return copiedArray;\n        } else {\n          return sliceAndSplice(combined, change.newIndex, 1, change);\n        }\n      }\n\n      break;\n\n    case 'removed':\n      if (combined[change.oldIndex] && combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n        return sliceAndSplice(combined, change.oldIndex, 1);\n      }\n\n      break;\n  }\n\n  return combined;\n}\n\nfunction validateEventsArray(events) {\n  if (!events || events.length === 0) {\n    events = ['added', 'removed', 'modified'];\n  }\n\n  return events;\n}\n/**\n * AngularFirestoreCollection service\n *\n * This class creates a reference to a Firestore Collection. A reference and a query are provided in\n * in the constructor. The query can be the unqueried reference if no query is desired.The class\n * is generic which gives you type safety for data update methods and data streaming.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const collectionRef = firebase.firestore.collection('stocks');\n * const query = collectionRef.where('price', '>', '0.01');\n * const fakeStock = new AngularFirestoreCollection<Stock>(collectionRef, query);\n *\n * // NOTE!: the updates are performed on the reference not the query\n * await fakeStock.add({ name: 'FAKE', price: 0.01 });\n *\n * // Subscribe to changes as snapshots. This provides you data updates as well as delta updates.\n * fakeStock.valueChanges().subscribe(value => console.log(value));\n */\n\n\nclass AngularFirestoreCollection {\n  /**\n   * The constructor takes in a CollectionReference and Query to provide wrapper methods\n   * for data operations and data streaming.\n   *\n   * Note: Data operation methods are done on the reference not the query. This means\n   * when you update data it is not updating data to the window of your query unless\n   * the data fits the criteria of the query. See the AssociatedRefence type for details\n   * on this implication.\n   */\n  constructor(ref, query, afs) {\n    this.ref = ref;\n    this.query = query;\n    this.afs = afs;\n  }\n  /**\n   * Listen to the latest change in the stream. This method returns changes\n   * as they occur and they are not sorted by query order. This allows you to construct\n   * your own data structure.\n   */\n\n\n  stateChanges(events) {\n    let source = docChanges(this.query, this.afs.schedulers.outsideAngular);\n\n    if (events && events.length > 0) {\n      source = source.pipe(map(actions => actions.filter(change => events.indexOf(change.type) > -1)));\n    }\n\n    return source.pipe( // We want to filter out empty arrays, but always emit at first, so the developer knows\n    // that the collection has been resolve; even if it's empty\n    startWith(undefined), pairwise(), filter(([prior, current]) => current.length > 0 || !prior), map(([prior, current]) => current), keepUnstableUntilFirst);\n  }\n  /**\n   * Create a stream of changes as they occur it time. This method is similar to stateChanges()\n   * but it collects each event in an array over time.\n   */\n\n\n  auditTrail(events) {\n    return this.stateChanges(events).pipe(scan((current, action) => [...current, ...action], []));\n  }\n  /**\n   * Create a stream of synchronized changes. This method keeps the local array in sorted\n   * query order.\n   */\n\n\n  snapshotChanges(events) {\n    const validatedEvents = validateEventsArray(events);\n    const scheduledSortedChanges$ = sortedChanges(this.query, validatedEvents, this.afs.schedulers.outsideAngular);\n    return scheduledSortedChanges$.pipe(keepUnstableUntilFirst);\n  }\n\n  valueChanges(options = {}) {\n    return fromCollectionRef(this.query, this.afs.schedulers.outsideAngular).pipe(map(actions => actions.payload.docs.map(a => {\n      if (options.idField) {\n        return Object.assign(Object.assign({}, a.data()), {\n          [options.idField]: a.id\n        });\n      } else {\n        return a.data();\n      }\n    })), keepUnstableUntilFirst);\n  }\n  /**\n   * Retrieve the results of the query once.\n   */\n\n\n  get(options) {\n    return from(this.query.get(options)).pipe(keepUnstableUntilFirst);\n  }\n  /**\n   * Add data to a collection reference.\n   *\n   * Note: Data operation methods are done on the reference not the query. This means\n   * when you update data it is not updating data to the window of your query unless\n   * the data fits the criteria of the query.\n   */\n\n\n  add(data) {\n    return this.ref.add(data);\n  }\n  /**\n   * Create a reference to a single document in a collection.\n   */\n\n\n  doc(path) {\n    // TODO is there a better way to solve this type issue\n    return new AngularFirestoreDocument(this.ref.doc(path), this.afs);\n  }\n\n}\n/**\n * AngularFirestoreDocument service\n *\n * This class creates a reference to a Firestore Document. A reference is provided in\n * in the constructor. The class is generic which gives you type safety for data update\n * methods and data streaming.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const fakeStock = new AngularFirestoreDocument<Stock>(doc('stocks/FAKE'));\n * await fakeStock.set({ name: 'FAKE', price: 0.01 });\n * fakeStock.valueChanges().map(snap => {\n *   if(snap.exists) return snap.data();\n *   return null;\n * }).subscribe(value => console.log(value));\n * // OR! Transform using Observable.from() and the data is unwrapped for you\n * Observable.from(fakeStock).subscribe(value => console.log(value));\n */\n\n\nclass AngularFirestoreDocument {\n  /**\n   * The constructor takes in a DocumentReference to provide wrapper methods\n   * for data operations, data streaming, and Symbol.observable.\n   */\n  constructor(ref, afs) {\n    this.ref = ref;\n    this.afs = afs;\n  }\n  /**\n   * Create or overwrite a single document.\n   */\n\n\n  set(data, options) {\n    return this.ref.set(data, options);\n  }\n  /**\n   * Update some fields of a document without overwriting the entire document.\n   */\n\n\n  update(data) {\n    return this.ref.update(data);\n  }\n  /**\n   * Delete a document.\n   */\n\n\n  delete() {\n    return this.ref.delete();\n  }\n  /**\n   * Create a reference to a sub-collection given a path and an optional query\n   * function.\n   */\n\n\n  collection(path, queryFn) {\n    const collectionRef = this.ref.collection(path);\n    const {\n      ref,\n      query\n    } = associateQuery(collectionRef, queryFn);\n    return new AngularFirestoreCollection(ref, query, this.afs);\n  }\n  /**\n   * Listen to snapshot updates from the document.\n   */\n\n\n  snapshotChanges() {\n    const scheduledFromDocRef$ = fromDocRef(this.ref, this.afs.schedulers.outsideAngular);\n    return scheduledFromDocRef$.pipe(keepUnstableUntilFirst);\n  }\n\n  valueChanges(options = {}) {\n    return this.snapshotChanges().pipe(map(({\n      payload\n    }) => options.idField ? Object.assign(Object.assign({}, payload.data()), {\n      [options.idField]: payload.id\n    }) : payload.data()));\n  }\n  /**\n   * Retrieve the document once.\n   */\n\n\n  get(options) {\n    return from(this.ref.get(options)).pipe(keepUnstableUntilFirst);\n  }\n\n}\n/**\n * AngularFirestoreCollectionGroup service\n *\n * This class holds a reference to a Firestore Collection Group Query.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const collectionGroup = firebase.firestore.collectionGroup('stocks');\n * const query = collectionRef.where('price', '>', '0.01');\n * const fakeStock = new AngularFirestoreCollectionGroup<Stock>(query, afs);\n *\n * // Subscribe to changes as snapshots. This provides you data updates as well as delta updates.\n * fakeStock.valueChanges().subscribe(value => console.log(value));\n */\n\n\nclass AngularFirestoreCollectionGroup {\n  /**\n   * The constructor takes in a CollectionGroupQuery to provide wrapper methods\n   * for data operations and data streaming.\n   */\n  constructor(query, afs) {\n    this.query = query;\n    this.afs = afs;\n  }\n  /**\n   * Listen to the latest change in the stream. This method returns changes\n   * as they occur and they are not sorted by query order. This allows you to construct\n   * your own data structure.\n   */\n\n\n  stateChanges(events) {\n    if (!events || events.length === 0) {\n      return docChanges(this.query, this.afs.schedulers.outsideAngular).pipe(keepUnstableUntilFirst);\n    }\n\n    return docChanges(this.query, this.afs.schedulers.outsideAngular).pipe(map(actions => actions.filter(change => events.indexOf(change.type) > -1)), filter(changes => changes.length > 0), keepUnstableUntilFirst);\n  }\n  /**\n   * Create a stream of changes as they occur it time. This method is similar to stateChanges()\n   * but it collects each event in an array over time.\n   */\n\n\n  auditTrail(events) {\n    return this.stateChanges(events).pipe(scan((current, action) => [...current, ...action], []));\n  }\n  /**\n   * Create a stream of synchronized changes. This method keeps the local array in sorted\n   * query order.\n   */\n\n\n  snapshotChanges(events) {\n    const validatedEvents = validateEventsArray(events);\n    const scheduledSortedChanges$ = sortedChanges(this.query, validatedEvents, this.afs.schedulers.outsideAngular);\n    return scheduledSortedChanges$.pipe(keepUnstableUntilFirst);\n  }\n\n  valueChanges(options = {}) {\n    const fromCollectionRefScheduled$ = fromCollectionRef(this.query, this.afs.schedulers.outsideAngular);\n    return fromCollectionRefScheduled$.pipe(map(actions => actions.payload.docs.map(a => {\n      if (options.idField) {\n        return Object.assign({\n          [options.idField]: a.id\n        }, a.data());\n      } else {\n        return a.data();\n      }\n    })), keepUnstableUntilFirst);\n  }\n  /**\n   * Retrieve the results of the query once.\n   */\n\n\n  get(options) {\n    return from(this.query.get(options)).pipe(keepUnstableUntilFirst);\n  }\n\n}\n/**\n * The value of this token determines whether or not the firestore will have persistance enabled\n */\n\n\nconst ENABLE_PERSISTENCE = /*#__PURE__*/new InjectionToken('angularfire2.enableFirestorePersistence');\nconst PERSISTENCE_SETTINGS = /*#__PURE__*/new InjectionToken('angularfire2.firestore.persistenceSettings');\nconst SETTINGS = /*#__PURE__*/new InjectionToken('angularfire2.firestore.settings');\nconst USE_EMULATOR = /*#__PURE__*/new InjectionToken('angularfire2.firestore.use-emulator');\n/**\n * A utility methods for associating a collection reference with\n * a query.\n *\n * @param collectionRef - A collection reference to query\n * @param queryFn - The callback to create a query\n *\n * Example:\n * const { query, ref } = associateQuery(docRef.collection('items'), ref => {\n *  return ref.where('age', '<', 200);\n * });\n */\n\nfunction associateQuery(collectionRef, queryFn = ref => ref) {\n  const query = queryFn(collectionRef);\n  const ref = collectionRef;\n  return {\n    query,\n    ref\n  };\n}\n/**\n * AngularFirestore Service\n *\n * This service is the main entry point for this feature module. It provides\n * an API for creating Collection and Reference services. These services can\n * then be used to do data updates and observable streams of the data.\n *\n * Example:\n *\n * import { Component } from '@angular/core';\n * import { AngularFirestore, AngularFirestoreCollection, AngularFirestoreDocument } from '@angular/fire/firestore';\n * import { Observable } from 'rxjs/Observable';\n * import { from } from 'rxjs/observable';\n *\n * @Component({\n *   selector: 'app-my-component',\n *   template: `\n *    <h2>Items for {{ (profile | async)?.name }}\n *    <ul>\n *       <li *ngFor=\"let item of items | async\">{{ item.name }}</li>\n *    </ul>\n *    <div class=\"control-input\">\n *       <input type=\"text\" #itemname />\n *       <button (click)=\"addItem(itemname.value)\">Add Item</button>\n *    </div>\n *   `\n * })\n * export class MyComponent implements OnInit {\n *\n *   // services for data operations and data streaming\n *   private readonly itemsRef: AngularFirestoreCollection<Item>;\n *   private readonly profileRef: AngularFirestoreDocument<Profile>;\n *\n *   // observables for template\n *   items: Observable<Item[]>;\n *   profile: Observable<Profile>;\n *\n *   // inject main service\n *   constructor(private readonly afs: AngularFirestore) {}\n *\n *   ngOnInit() {\n *     this.itemsRef = afs.collection('items', ref => ref.where('user', '==', 'davideast').limit(10));\n *     this.items = this.itemsRef.valueChanges().map(snap => snap.docs.map(data => doc.data()));\n *     // this.items = from(this.itemsRef); // you can also do this with no mapping\n *\n *     this.profileRef = afs.doc('users/davideast');\n *     this.profile = this.profileRef.valueChanges();\n *   }\n *\n *   addItem(name: string) {\n *     const user = 'davideast';\n *     this.itemsRef.add({ name, user });\n *   }\n * }\n */\n\n\nlet AngularFirestore = /*#__PURE__*/(() => {\n  class AngularFirestore {\n    /**\n     * Each Feature of AngularFire has a FirebaseApp injected. This way we\n     * don't rely on the main Firebase App instance and we can create named\n     * apps and use multiple apps.\n     */\n    constructor(options, name, shouldEnablePersistence, settings, // tslint:disable-next-line:ban-types\n    platformId, zone, schedulers, persistenceSettings, _useEmulator, auth, useAuthEmulator, authSettings, // can't use firebase.auth.AuthSettings here\n    tenantId, languageCode, useDeviceLanguage, persistence, _appCheckInstances) {\n      this.schedulers = schedulers;\n      const app = ɵfirebaseAppFactory(options, zone, name);\n      const useEmulator = _useEmulator;\n\n      if (auth) {\n        ɵauthFactory(app, zone, useAuthEmulator, tenantId, languageCode, useDeviceLanguage, authSettings, persistence);\n      }\n\n      [this.firestore, this.persistenceEnabled$] = ɵcacheInstance(`${app.name}.firestore`, 'AngularFirestore', app.name, () => {\n        const firestore = zone.runOutsideAngular(() => app.firestore());\n\n        if (settings) {\n          firestore.settings(settings);\n        }\n\n        if (useEmulator) {\n          firestore.useEmulator(...useEmulator);\n        }\n\n        if (shouldEnablePersistence && !isPlatformServer(platformId)) {\n          // We need to try/catch here because not all enablePersistence() failures are caught\n          // https://github.com/firebase/firebase-js-sdk/issues/608\n          const enablePersistence = () => {\n            try {\n              return from(firestore.enablePersistence(persistenceSettings || undefined).then(() => true, () => false));\n            } catch (e) {\n              if (typeof console !== 'undefined') {\n                console.warn(e);\n              }\n\n              return of(false);\n            }\n          };\n\n          return [firestore, zone.runOutsideAngular(enablePersistence)];\n        } else {\n          return [firestore, of(false)];\n        }\n      }, [settings, useEmulator, shouldEnablePersistence]);\n    }\n\n    collection(pathOrRef, queryFn) {\n      let collectionRef;\n\n      if (typeof pathOrRef === 'string') {\n        collectionRef = this.firestore.collection(pathOrRef);\n      } else {\n        collectionRef = pathOrRef;\n      }\n\n      const {\n        ref,\n        query\n      } = associateQuery(collectionRef, queryFn);\n      const refInZone = this.schedulers.ngZone.run(() => ref);\n      return new AngularFirestoreCollection(refInZone, query, this);\n    }\n    /**\n     * Create a reference to a Firestore Collection Group based on a collectionId\n     * and an optional query function to narrow the result\n     * set.\n     */\n\n\n    collectionGroup(collectionId, queryGroupFn) {\n      const queryFn = queryGroupFn || (ref => ref);\n\n      const collectionGroup = this.firestore.collectionGroup(collectionId);\n      return new AngularFirestoreCollectionGroup(queryFn(collectionGroup), this);\n    }\n\n    doc(pathOrRef) {\n      let ref;\n\n      if (typeof pathOrRef === 'string') {\n        ref = this.firestore.doc(pathOrRef);\n      } else {\n        ref = pathOrRef;\n      }\n\n      const refInZone = this.schedulers.ngZone.run(() => ref);\n      return new AngularFirestoreDocument(refInZone, this);\n    }\n    /**\n     * Returns a generated Firestore Document Id.\n     */\n\n\n    createId() {\n      return this.firestore.collection('_').doc().id;\n    }\n\n  }\n\n  AngularFirestore.ɵfac = function AngularFirestore_Factory(t) {\n    return new (t || AngularFirestore)(i0.ɵɵinject(FIREBASE_OPTIONS), i0.ɵɵinject(FIREBASE_APP_NAME, 8), i0.ɵɵinject(ENABLE_PERSISTENCE, 8), i0.ɵɵinject(SETTINGS, 8), i0.ɵɵinject(PLATFORM_ID), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i1.ɵAngularFireSchedulers), i0.ɵɵinject(PERSISTENCE_SETTINGS, 8), i0.ɵɵinject(USE_EMULATOR, 8), i0.ɵɵinject(i2.AngularFireAuth, 8), i0.ɵɵinject(USE_EMULATOR$1, 8), i0.ɵɵinject(SETTINGS$1, 8), i0.ɵɵinject(TENANT_ID, 8), i0.ɵɵinject(LANGUAGE_CODE, 8), i0.ɵɵinject(USE_DEVICE_LANGUAGE, 8), i0.ɵɵinject(PERSISTENCE, 8), i0.ɵɵinject(i3.AppCheckInstances, 8));\n  };\n\n  AngularFirestore.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AngularFirestore,\n    factory: AngularFirestore.ɵfac,\n    providedIn: 'any'\n  });\n  return AngularFirestore;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet AngularFirestoreModule = /*#__PURE__*/(() => {\n  class AngularFirestoreModule {\n    constructor() {\n      firebase.registerVersion('angularfire', VERSION.full, 'fst-compat');\n    }\n    /**\n     * Attempt to enable persistent storage, if possible\n     */\n\n\n    static enablePersistence(persistenceSettings) {\n      return {\n        ngModule: AngularFirestoreModule,\n        providers: [{\n          provide: ENABLE_PERSISTENCE,\n          useValue: true\n        }, {\n          provide: PERSISTENCE_SETTINGS,\n          useValue: persistenceSettings\n        }]\n      };\n    }\n\n  }\n\n  AngularFirestoreModule.ɵfac = function AngularFirestoreModule_Factory(t) {\n    return new (t || AngularFirestoreModule)();\n  };\n\n  AngularFirestoreModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: AngularFirestoreModule\n  });\n  AngularFirestoreModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [AngularFirestore]\n  });\n  return AngularFirestoreModule;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { AngularFirestore, AngularFirestoreCollection, AngularFirestoreCollectionGroup, AngularFirestoreDocument, AngularFirestoreModule, ENABLE_PERSISTENCE, PERSISTENCE_SETTINGS, SETTINGS, USE_EMULATOR, associateQuery, combineChange, combineChanges, docChanges, fromCollectionRef, fromDocRef, fromRef, sortedChanges, validateEventsArray }; //# sourceMappingURL=angular-fire-compat-firestore.js.map","map":null,"metadata":{},"sourceType":"module"}